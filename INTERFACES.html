<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ipopt: Interfacing your NLP to Ipopt</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 40px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ipopt Documentation
   &#160;<!--span id="projectnumber">3.14.0</span-->
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('INTERFACES.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Interfacing your NLP to Ipopt </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#INTERFACE_AMPL">Using Ipopt through AMPL</a><ul><li class="level2"><a href="#INTERFACE_AMPL_CL">Using Ipopt from the command line</a></li>
</ul>
</li>
<li class="level1"><a href="#INTERFACE_CODE">Interfacing with Ipopt through code</a><ul><li class="level2"><a href="#INTERFACE_CPP">The C++ Interface</a><ul><li class="level3"><a href="#INTERFACE_CPP_NLP">Coding the Problem Representation</a></li>
<li class="level3"><a href="#INTERFACE_CPP_MAIN">Coding the Executable</a></li>
<li class="level3"><a href="#INTERFACE_CPP_COMPILE">Compiling and Testing the Example</a></li>
<li class="level3"><a href="#INTERFACE_CPP_ADDITIONAL">Additional methods in TNLP</a></li>
</ul>
</li>
<li class="level2"><a href="#INTERFACE_C">The C Interface</a></li>
<li class="level2"><a href="#INTERFACE_FORTRAN">The Fortran Interface</a></li>
<li class="level2"><a href="#INTERFACE_JAVA">The Java Interface JIpopt</a></li>
<li class="level2"><a href="#INTERFACE_R">The R Interface ipoptr</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Method to request the initial information about the problem.</p>
<p>Ipopt has been designed to be flexible for a wide variety of applications, and there are a number of ways to interface with Ipopt that allow specific data structures and linear solver techniques. Nevertheless, the authors have included a standard representation that should meet the needs of most users.</p>
<p>This tutorial will discuss six interfaces to Ipopt, namely the AMPL modeling language <a class="el" href="citelist.html#CITEREF_FouGayKer:AMPLbook">[5]</a> interface, and the C++, C, Fortran, Java, and R code interfaces. AMPL is a modeling language tool that allows users to write their optimization problem in a syntax that resembles the way the problem would be written mathematically. Once the problem has been formulated in AMPL, the problem can be easily solved using the (already compiled) Ipopt AMPL solver executable, ipopt. Interfacing your problem by directly linking code requires more effort to write, but can be far more efficient for large problems.</p>
<p>We will illustrate how to use each of the four interfaces using an example problem, number 71 from the Hock-Schittkowsky test suite <a class="el" href="citelist.html#CITEREF_HS">[6]</a>, </p><p class="formulaDsp">
\begin{equation} \begin{aligned} \min_{x \in \Re^4} &amp;&amp;x_1 x_4 (x_1 + x_2 + x_3) + x_3 \\ \mbox{s.t.} &amp;&amp;x_1 x_2 x_3 x_4 \ge 25 \\ &amp;&amp;x_1^2 + x_2^2 + x_3^2 + x_4^2 = 40 \\ &amp;&amp;1 \leq x_1, x_2, x_3, x_4 \leq 5, \end{aligned} \tag{HS071} \end{equation}
</p>
<p> with the starting point </p><p class="formulaDsp">
\[ x_0 = (1, 5, 5, 1) \]
</p>
<p> and the optimal solution </p><p class="formulaDsp">
\[ x_* = (1.00000000, 4.74299963, 3.82114998, 1.37940829). \]
</p>
<p>You can find further, less documented examples for using Ipopt from your own source code in the Ipopt/examples subdirectory.</p>
<h1><a class="anchor" id="INTERFACE_AMPL"></a>
Using Ipopt through AMPL</h1>
<p>Using the AMPL solver executable is by far the easiest way to solve a problem with Ipopt. The user must simply formulate the problem in AMPL syntax, and solve the problem through the AMPL environment. There are drawbacks, however. AMPL is a 3rd party package and, as such, must be appropriately licensed (a free student version for limited problem size is available from the <a href="http://www.ampl.com">AMPL website</a>. Furthermore, the AMPL environment may be prohibitive for very large problems. Nevertheless, formulating the problem in AMPL is straightforward and even for large problems, it is often used as a prototyping tool before using one of the code interfaces.</p>
<p>This tutorial is not intended as a guide to formulating models in AMPL. If you are not already familiar with AMPL, please consult <a class="el" href="citelist.html#CITEREF_FouGayKer:AMPLbook">[5]</a>.</p>
<p>The problem presented in (HS071) can be solved with Ipopt with the following AMPL model. </p><pre class="fragment"># tell ampl to use the ipopt executable as a solver
# make sure ipopt is in the path!
option solver ipopt;

# declare the variables and their bounds,
# set notation could be used, but this is straightforward
var x1 &gt;= 1, &lt;= 5;
var x2 &gt;= 1, &lt;= 5;
var x3 &gt;= 1, &lt;= 5;
var x4 &gt;= 1, &lt;= 5;

# specify the objective function
minimize obj:
    x1 * x4 * (x1 + x2 + x3) + x3;

# specify the constraints
s.t.
  inequality:
    x1 * x2 * x3 * x4 &gt;= 25;

  equality:
    x1^2 + x2^2 + x3^2 +x4^2 = 40;

# specify the starting point
let x1 := 1;
let x2 := 5;
let x3 := 5;
let x4 := 1;

# solve the problem
solve;

# print the solution
display x1;
display x2;
display x3;
display x4;
</pre><p>The line, <code>option solver ipopt;</code> tells AMPL to use Ipopt as the solver. The Ipopt executable (installed in <a class="el" href="INSTALL.html#COMPILEINSTALL">Compiling and Installing Ipopt</a>) must be in the <code>PATH</code> for AMPL to find it. The remaining lines specify the problem in AMPL format. The problem can now be solved by starting AMPL and loading the mod file: </p><pre class="fragment">$ ampl
&gt; model hs071_ampl.mod;
.
.
.
</pre><p>The problem will be solved using Ipopt and the solution will be displayed.</p>
<p>At this point, AMPL users may wish to skip the sections about interfacing with code, but should read <a class="el" href="OPTIONS.html">Ipopt Options</a> and <a class="el" href="OUTPUT.html">Ipopt Output</a>.</p>
<h2><a class="anchor" id="INTERFACE_AMPL_CL"></a>
Using Ipopt from the command line</h2>
<p>It is possible to solve AMPL problems with Ipopt directly from the command line. However, this requires a file in format <code>.nl</code> produced by ampl. If you have a model and data loaded in Ampl, you can create the corresponding <code>.nl</code> file with name, say, <code>myprob.nl</code> by using the Ampl command: </p><pre class="fragment">write gmyprob
</pre><p>There is a small <code>.nl</code> file available in the Ipopt distribution. It is located at <code>Ipopt/test/mytoy.nl</code>. We use this file in the remainder of this section. We assume that the file <code>mytoy.nl</code> is in the current directory and that the command <code>ipopt</code> is a shortcut for running the Ipopt binary available in the <code>bin</code> directory of the installation of Ipopt.</p>
<p>We list below commands to perform basic tasks from the Linux prompt.</p>
<ul>
<li>To solve mytoy.nl from the Linux prompt, use: <pre class="fragment">ipopt mytoy
</pre></li>
<li>To see all command line options for Ipopt, use: <pre class="fragment">ipopt -=
</pre></li>
<li>To see more detailed information on all options for Ipopt: <pre class="fragment">ipopt mytoy 'print_options_documentation yes'
</pre></li>
<li>To run ipopt, setting the maximum number of iterations to 2 and print level to 4: <pre class="fragment">ipopt mytoy 'max_iter 2 print_level 4'
</pre></li>
</ul>
<p>If many options are to be set, they can be collected in a file <code>ipopt.opt</code> that is automatically read by Ipopt, if present, in the current directory, see also <a class="el" href="OPTIONS.html">Ipopt Options</a>.</p>
<h1><a class="anchor" id="INTERFACE_CODE"></a>
Interfacing with Ipopt through code</h1>
<p>In order to solve a problem, Ipopt needs more information than just the problem definition (for example, the derivative information). If you are using a modeling language like AMPL, the extra information is provided by the modeling tool and the Ipopt interface. When interfacing with Ipopt through your own code, however, you must provide this additional information. The following information is required by Ipopt:</p>
<ol type="1">
<li>Problem dimensions<ul>
<li>number of variables</li>
<li>number of constraints</li>
</ul>
</li>
<li>Problem bounds<ul>
<li>variable bounds</li>
<li>constraint bounds</li>
</ul>
</li>
<li>Initial starting point<ul>
<li>Initial values for the primal \(x\) variables</li>
<li>Initial values for the multipliers (only required for a warm start option)</li>
</ul>
</li>
<li>Problem Structure<ul>
<li>number of nonzeros in the Jacobian of the constraints</li>
<li>number of nonzeros in the Hessian of the Lagrangian function</li>
<li>sparsity structure of the Jacobian of the constraints</li>
<li>sparsity structure of the Hessian of the Lagrangian function</li>
</ul>
</li>
<li>Evaluation of Problem Functions <br  />
 Information evaluated using a given point ( \(x\), \(\lambda\), \(\sigma_f\) coming from Ipopt)<ul>
<li>Objective function, \(f(x)\)</li>
<li>Gradient of the objective, \(\nabla f(x)\)</li>
<li>Constraint function values, \(g(x)\)</li>
<li>Jacobian of the constraints, \(\nabla g(x)^T\)</li>
<li>Hessian of the Lagrangian function, \(\sigma_f \nabla^2 f(x) + \sum_{i=1}^m\lambda_i\nabla^2 g_i(x)\) <br  />
 (this is not required if a quasi-Newton options is chosen to approximate the second derivatives)</li>
</ul>
</li>
</ol>
<p>The problem dimensions and bounds are straightforward and come solely from the problem definition. The initial starting point is used by the algorithm when it begins iterating to solve the problem. If Ipopt has difficulty converging, or if it converges to a locally infeasible point, adjusting the starting point may help. Depending on the starting point, Ipopt may also converge to different local solutions.</p>
<p>Providing the sparsity structure of derivative matrices is a bit more involved. Ipopt is a nonlinear programming solver that is designed for solving large-scale, sparse problems. While Ipopt can be customized for a variety of matrix formats, the triplet format is used for the standard interfaces in this tutorial. For an overview of the triplet format for sparse matrices, see <a class="el" href="IMPL.html#TRIPLET">Triplet Format for Sparse Matrices</a>. Before solving the problem, Ipopt needs to know the number of nonzero elements and the sparsity structure (row and column indices of each of the nonzero entries) of the constraint Jacobian and the Lagrangian function Hessian. Once defined, this nonzero structure MUST remain constant for the entire optimization procedure. This means that the structure needs to include entries for any element that could ever be nonzero, not only those that are nonzero at the starting point.</p>
<p>As Ipopt iterates, it will need the values for problem functions evaluated at particular points. Before we can begin coding the interface, however, we need to work out the details of these equations symbolically for example problem (HS071).</p>
<p>The gradient of the objective \(f(x)\) is given by </p><p class="formulaDsp">
\[\left[ \begin{array}{c} x_1 x_4 + x_4 (x_1 + x_2 + x_3) \\ x_1 x_4 \\ x_1 x_4 + 1 \\ x_1 (x_1 + x_2 + x_3) \end{array} \right]\]
</p>
<p> and the Jacobian of the constraints \(g(x)\) is </p><p class="formulaDsp">
\[\left[ \begin{array}{cccc} x_2 x_3 x_4 &amp; x_1 x_3 x_4 &amp; x_1 x_2 x_4 &amp; x_1 x_2 x_3 \\ 2 x_1 &amp; 2 x_2 &amp; 2 x_3 &amp; 2 x_4 \end{array} \right]. \]
</p>
<p>We also need to determine the Hessian of the Lagrangian. (If a quasi-Newton option is chosen to approximate the second derivatives, this is not required. However, if second derivatives can be computed, it is often worthwhile to let Ipopt use them, since the algorithm is then usually more robust and converges faster. More on the quasi-Newton approximation in <a class="el" href="SPECIALS.html#QUASI_NEWTON">Quasi-Newton Approximation of Second Derivatives</a>.) The Lagrangian function for the NLP (HS071) is defined as \(f(x) + g(x)^T \lambda\) and the Hessian of the Lagrangian function is, technically, \(\nabla^2 f(x_k) + \sum_{i=1}^m\lambda_i\nabla^2 g_i(x_k)\). However, we introduce a factor ( \(\sigma_f\)) in front of the objective term so that Ipopt can ask for the Hessian of the objective or the constraints independently, if required. Thus, for Ipopt the symbolic form of the Hessian of the Lagrangian is </p><p class="formulaDsp">
\[ \sigma_f \nabla^2 f(x_k) + \sum_{i=1}^m\lambda_i\nabla^2 g_i(x_k) \]
</p>
<p> and for the example problem this becomes </p><p class="formulaDsp">
\[ \sigma_f \left[ \begin{array}{cccc} 2 x_4 &amp; x_4 &amp; x_4 &amp; 2 x_1 + x_2 + x_3 \\ x_4 &amp; 0 &amp; 0 &amp; x_1 \\ x_4 &amp; 0 &amp; 0 &amp; x_1 \\ 2 x_1+x_2+x_3 &amp; x_1 &amp; x_1 &amp; 0 \end{array} \right] + \lambda_1 \left[ \begin{array}{cccc} 0 &amp; x_3 x_4 &amp; x_2 x_4 &amp; x_2 x_3 \\ x_3 x_4 &amp; 0 &amp; x_1 x_4 &amp; x_1 x_3 \\ x_2 x_4 &amp; x_1 x_4 &amp; 0 &amp; x_1 x_2 \\ x_2 x_3 &amp; x_1 x_3 &amp; x_1 x_2 &amp; 0 \end{array} \right] + \lambda_2 \left[ \begin{array}{cccc} 2 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 2 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 2 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 2 \end{array} \right]\]
</p>
<p> where the first term comes from the Hessian of the objective function, and the second and third term from the Hessian of the constraints. Therefore, the dual variables \(\lambda_1\) and \(\lambda_2\) are the multipliers for the constraints.</p>
<p>The remaining sections of the tutorial will lead you through the coding required to solve example problem (HS071) using, first C++, then C, and finally Fortran. Completed versions of these examples can be found in <code>$IPOPTDIR/Ipopt/examples</code> under <code>hs071_cpp</code>, <code>hs071_c</code>, and <code>hs071_f</code>.</p>
<p>As a user, you are responsible for coding two sections of the program that solves a problem using Ipopt: the main executable (e.g., main) and the problem representation. Typically, you will write an executable that prepares the problem, and then passes control over to Ipopt through an Optimize or Solve call. In this call, you will give Ipopt everything that it requires to call back to your code whenever it needs functions evaluated (like the objective function, the Jacobian of the constraints, etc.). In each of the three sections that follow (C++, C, and Fortran), we will first discuss how to code the problem representation, and then how to code the executable.</p>
<h2><a class="anchor" id="INTERFACE_CPP"></a>
The C++ Interface</h2>
<p>This tutorial assumes that you are familiar with the C++ programming language, however, we will lead you through each step of the implementation. For the problem representation, we will create a class that inherits off of the pure virtual base class, <a class="el" href="classIpopt_1_1TNLP.html" title="Base class for all NLP&#39;s that use standard triplet matrix form and dense vectors.">Ipopt::TNLP</a>. For the executable (the main function) we will make the call to Ipopt through the <a class="el" href="classIpopt_1_1IpoptApplication.html" title="This is the main application class for making calls to Ipopt.">Ipopt::IpoptApplication</a> class. In addition, we will also be using the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers.">Ipopt::SmartPtr</a> class which implements a reference counting pointer that takes care of memory management (object deletion) for you (for details, see <a class="el" href="IMPL.html#SMARTPTR">The Smart Pointer Implementation: SmartPtr&lt;T&gt;</a>).</p>
<p>After <code>make install</code> (see <a class="el" href="INSTALL.html#COMPILEINSTALL">Compiling and Installing Ipopt</a>), the header files that define these classes are installed in <code>$PREFIX/include/coin-or</code>.</p>
<h3><a class="anchor" id="INTERFACE_CPP_NLP"></a>
Coding the Problem Representation</h3>
<p>We provide the required information by coding the HS071_NLP class, a specific implementation of the TNLP base class. In the executable, we will create an instance of the HS071_NLP class and give this class to Ipopt so it can evaluate the problem functions through the <a class="el" href="classIpopt_1_1TNLP.html" title="Base class for all NLP&#39;s that use standard triplet matrix form and dense vectors.">Ipopt::TNLP</a> interface. If you have any difficulty as the implementation proceeds, have a look at the completed example in the <code>Ipopt/examples/hs071_cpp</code> directory.</p>
<p>Start by creating a new directory <code>MyExample</code> under examples and create the files hs071_nlp.hpp and hs071_nlp.cpp. In hs071_nlp.hpp, include <a class="el" href="IpTNLP_8hpp.html">IpTNLP.hpp</a> (the base class), tell the compiler that we are using the namespace <a class="el" href="namespaceIpopt.html" title="This file contains a base class for all exceptions and a set of macros to help with exceptions.">Ipopt</a>, and create the declaration of the HS071_NLP class, inheriting off of TNLP. Have a look at the <a class="el" href="classIpopt_1_1TNLP.html" title="Base class for all NLP&#39;s that use standard triplet matrix form and dense vectors.">Ipopt::TNLP</a> class; you will see eight pure virtual methods that we must implement. Declare these methods in the header file. Implement each of the methods in HS071_NLP.cpp using the descriptions given below. In hs071_nlp.cpp, first include the header file for your class and tell the compiler that you are using the namespace <a class="el" href="namespaceIpopt.html" title="This file contains a base class for all exceptions and a set of macros to help with exceptions.">Ipopt</a>. A full version of these files can be found in the <code>Ipopt/examples/hs071_cpp</code> directory.</p>
<p>It is very easy to make mistakes in the implementation of the function evaluation methods, in particular regarding the derivatives. Ipopt has a feature that can help you to debug the derivative code, using finite differences, see <a class="el" href="SPECIALS.html#DERIVCHECK">Derivative Checker</a>.</p>
<p>Note that the return value of any bool-valued function should be true, unless an error occurred, for example, because the value of a problem function could not be evaluated at the required point.</p>
<p><a class="el" href="classIpopt_1_1TNLP.html#a5da5791365764706aeda02b78f7719b6">Ipopt::TNLP::get_nlp_info</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_nlp_info(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>&amp;          n,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>&amp;          m,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>&amp;          nnz_jac_g,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>&amp;          nnz_h_lag,</div>
<div class="line">      IndexStyleEnum&amp; index_style</div>
<div class="line">   ) = 0;</div>
</div><!-- fragment --><p> Ipopt uses this information when allocating the arrays that it will later ask you to fill with values. Be careful in this method since incorrect values will cause memory bugs which may be very difficult to find.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(out) Storage for the number of variables \(x\) </td></tr>
    <tr><td class="paramname">m</td><td>(out) Storage for the number of constraints \(g(x)\) </td></tr>
    <tr><td class="paramname">nnz_jac_g</td><td>(out) Storage for the number of nonzero entries in the Jacobian </td></tr>
    <tr><td class="paramname">nnz_h_lag</td><td>(out) Storage for the number of nonzero entries in the Hessian </td></tr>
    <tr><td class="paramname">index_style</td><td>(out) Storage for the index style, the numbering style used for row/col entries in the sparse matrix format (TNLP::C_STYLE: 0-based, TNLP::FORTRAN_STYLE: 1-based; see also <a class="el" href="IMPL.html#TRIPLET">Triplet Format for Sparse Matrices</a>) </td></tr>
  </table>
  </dd>
</dl>
</blockquote>
<p>Our example problem has 4 variables (n), and 2 constraints (m). The constraint Jacobian for this small problem is actually dense and has 8 nonzeros (we still need to represent this Jacobian using the sparse matrix triplet format). The Hessian of the Lagrangian has 10 "symmetric" nonzeros (i.e., nonzeros in the lower left triangular part.). Keep in mind that the number of nonzeros is the total number of elements that may <em>ever</em> be nonzero, not just those that are nonzero at the starting point. This information is set once for the entire problem.</p>
<div class="fragment"><div class="line"><span class="comment">// returns the size of the problem</span></div>
<div class="line"><span class="keywordtype">bool</span> HS071_NLP::get_nlp_info(</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>&amp;          n,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>&amp;          m,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>&amp;          nnz_jac_g,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>&amp;          nnz_h_lag,</div>
<div class="line">   IndexStyleEnum&amp; index_style</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// The problem described in HS071_NLP.hpp has 4 variables, x[0] through x[3]</span></div>
<div class="line">   n = 4;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// one equality constraint and one inequality constraint</span></div>
<div class="line">   m = 2;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// in this example the jacobian is dense and contains 8 nonzeros</span></div>
<div class="line">   nnz_jac_g = 8;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// the Hessian is also dense and has 16 total nonzeros, but we</span></div>
<div class="line">   <span class="comment">// only need the lower left corner (since it is symmetric)</span></div>
<div class="line">   nnz_h_lag = 10;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// use the C style indexing (0-based)</span></div>
<div class="line">   index_style = TNLP::C_STYLE;</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="classIpopt_1_1TNLP.html#aafb65734cce3659c6fb496e136636e9e">Ipopt::TNLP::get_bounds_info</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_bounds_info(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>   n,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x_l,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x_u,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>   m,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* g_l,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* g_u</div>
<div class="line">   ) = 0;</div>
</div><!-- fragment --><p>Method to request bounds on the variables and constraints. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(in) the number of variables \(x\) in the problem </td></tr>
    <tr><td class="paramname">x_l</td><td>(out) the lower bounds \(x^L\) for the variables \(x\) </td></tr>
    <tr><td class="paramname">x_u</td><td>(out) the upper bounds \(x^U\) for the variables \(x\) </td></tr>
    <tr><td class="paramname">m</td><td>(in) the number of constraints \(g(x)\) in the problem </td></tr>
    <tr><td class="paramname">g_l</td><td>(out) the lower bounds \(g^L\) for the constraints \(g(x)\) </td></tr>
    <tr><td class="paramname">g_u</td><td>(out) the upper bounds \(g^U\) for the constraints \(g(x)\)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false otherwise.</dd></dl>
<p>The values of <code>n</code> and <code>m</code> that were specified in TNLP::get_nlp_info are passed here for debug checking. Setting a lower bound to a value less than or equal to the value of the option <a class="el" href="OPTIONS.html#OPT_nlp_lower_bound_inf">nlp_lower_bound_inf</a> will cause Ipopt to assume no lower bound. Likewise, specifying the upper bound above or equal to the value of the option <a class="el" href="OPTIONS.html#OPT_nlp_upper_bound_inf">nlp_upper_bound_inf</a> will cause Ipopt to assume no upper bound. These options are set to -10<sup>19</sup> and 10<sup>19</sup>, respectively, by default, but may be modified by changing these options. </p>
</blockquote>
<p>In our example, the first constraint has a lower bound of 25 and no upper bound, so we set the lower bound of constraint to 25 and the upper bound to some number greater than 10<sup>19</sup>. The second constraint is an equality constraint and we set both bounds to 40. Ipopt recognizes this as an equality constraint and does not treat it as two inequalities.</p>
<div class="fragment"><div class="line"><span class="comment">// returns the variable bounds</span></div>
<div class="line"><span class="keywordtype">bool</span> HS071_NLP::get_bounds_info(</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>   n,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x_l,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x_u,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>   m,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* g_l,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* g_u</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// here, the n and m we gave IPOPT in get_nlp_info are passed back to us.</span></div>
<div class="line">   <span class="comment">// If desired, we could assert to make sure they are what we think they are.</span></div>
<div class="line">   assert(n == 4);</div>
<div class="line">   assert(m == 2);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// the variables have lower bounds of 1</span></div>
<div class="line">   <span class="keywordflow">for</span>( <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a> i = 0; i &lt; 4; i++ )</div>
<div class="line">   {</div>
<div class="line">      x_l[i] = 1.0;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// the variables have upper bounds of 5</span></div>
<div class="line">   <span class="keywordflow">for</span>( <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a> i = 0; i &lt; 4; i++ )</div>
<div class="line">   {</div>
<div class="line">      x_u[i] = 5.0;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// the first constraint g1 has a lower bound of 25</span></div>
<div class="line">   g_l[0] = 25;</div>
<div class="line">   <span class="comment">// the first constraint g1 has NO upper bound, here we set it to 2e19.</span></div>
<div class="line">   <span class="comment">// Ipopt interprets any number greater than nlp_upper_bound_inf as</span></div>
<div class="line">   <span class="comment">// infinity. The default value of nlp_upper_bound_inf and nlp_lower_bound_inf</span></div>
<div class="line">   <span class="comment">// is 1e19 and can be changed through ipopt options.</span></div>
<div class="line">   g_u[0] = 2e19;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// the second constraint g2 is an equality constraint, so we set the</span></div>
<div class="line">   <span class="comment">// upper and lower bound to the same value</span></div>
<div class="line">   g_l[1] = g_u[1] = 40.0;</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="classIpopt_1_1TNLP.html#a0ae4075da9928e518780bba865698545">Ipopt::TNLP::get_starting_point</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_starting_point(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>   n,</div>
<div class="line">      <span class="keywordtype">bool</span>    init_x,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">      <span class="keywordtype">bool</span>    init_z,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* z_L,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* z_U,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>   m,</div>
<div class="line">      <span class="keywordtype">bool</span>    init_lambda,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* lambda</div>
<div class="line">   ) = 0;</div>
</div><!-- fragment --><p>Method to request the starting point before iterating. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(in) the number of variables \(x\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">init_x</td><td>(in) if true, this method must provide an initial value for \(x\) </td></tr>
    <tr><td class="paramname">x</td><td>(out) the initial values for the primal variables \(x\) </td></tr>
    <tr><td class="paramname">init_z</td><td>(in) if true, this method must provide an initial value for the bound multipliers \(z^L\) and \(z^U\) </td></tr>
    <tr><td class="paramname">z_L</td><td>(out) the initial values for the bound multipliers \(z^L\) </td></tr>
    <tr><td class="paramname">z_U</td><td>(out) the initial values for the bound multipliers \(z^U\) </td></tr>
    <tr><td class="paramname">m</td><td>(in) the number of constraints \(g(x)\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">init_lambda</td><td>(in) if true, this method must provide an initial value for the constraint multipliers \(\lambda\) </td></tr>
    <tr><td class="paramname">lambda</td><td>(out) the initial values for the constraint multipliers, \(\lambda\)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false otherwise.</dd></dl>
<p>The boolean variables indicate whether the algorithm requires to have x, z_L/z_u, and lambda initialized, respectively. If, for some reason, the algorithm requires initializations that cannot be provided, false should be returned and Ipopt will stop. The default options only require initial values for the primal variables \(x\).</p>
<p>Note, that the initial values for bound multiplier components for absent bounds ( \(x^L_i=-\infty\) or \(x^U_i=\infty\)) are ignored. </p>
</blockquote>
<p>In our example, we provide initial values for \(x\) as specified in the example problem. We do not provide any initial values for the dual variables, but use an assert to immediately let us know if we are ever asked for them.</p>
<div class="fragment"><div class="line"><span class="comment">// returns the initial point for the problem</span></div>
<div class="line"><span class="keywordtype">bool</span> HS071_NLP::get_starting_point(</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>   n,</div>
<div class="line">   <span class="keywordtype">bool</span>    init_x,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">   <span class="keywordtype">bool</span>    init_z,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* z_L,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* z_U,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>   m,</div>
<div class="line">   <span class="keywordtype">bool</span>    init_lambda,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* lambda</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Here, we assume we only have starting values for x, if you code</span></div>
<div class="line">   <span class="comment">// your own NLP, you can provide starting values for the dual variables</span></div>
<div class="line">   <span class="comment">// if you wish</span></div>
<div class="line">   assert(init_x == <span class="keyword">true</span>);</div>
<div class="line">   assert(init_z == <span class="keyword">false</span>);</div>
<div class="line">   assert(init_lambda == <span class="keyword">false</span>);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// initialize to the given starting point</span></div>
<div class="line">   x[0] = 1.0;</div>
<div class="line">   x[1] = 5.0;</div>
<div class="line">   x[2] = 5.0;</div>
<div class="line">   x[3] = 1.0;</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="classIpopt_1_1TNLP.html#a709c03900227bc573b046ce0705e6c84">Ipopt::TNLP::eval_f</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> eval_f(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         n,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">      <span class="keywordtype">bool</span>          new_x,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>&amp;       obj_value</div>
<div class="line">   ) = 0;</div>
</div><!-- fragment --><p>Method to request the value of the objective function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(in) the number of variables \(x\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">x</td><td>(in) the values for the primal variables \(x\) at which the objective function \(f(x)\) is to be evaluated </td></tr>
    <tr><td class="paramname">new_x</td><td>(in) false if any evaluation method (<code>eval_*</code>) was previously called with the same values in x, true otherwise. This can be helpful when users have efficient implementations that calculate multiple outputs at once. Ipopt internally caches results from the TNLP and generally, this flag can be ignored. </td></tr>
    <tr><td class="paramname">obj_value</td><td>(out) storage for the value of the objective function \(f(x)\)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false otherwise. </dd></dl>
</blockquote>
<p>For our example, we ignore the <code>new_x</code> flag and calculate the objective.</p>
<div class="fragment"><div class="line"><span class="comment">// returns the value of the objective function</span></div>
<div class="line"><span class="keywordtype">bool</span> HS071_NLP::eval_f(</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         n,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">   <span class="keywordtype">bool</span>          new_x,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>&amp;       obj_value</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">   assert(n == 4);</div>
<div class="line"> </div>
<div class="line">   obj_value = x[0] * x[3] * (x[0] + x[1] + x[2]) + x[2];</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="classIpopt_1_1TNLP.html#a52698f1861ffef271d5e317c0e168652">Ipopt::TNLP::eval_grad_f</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> eval_grad_f(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         n,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">      <span class="keywordtype">bool</span>          new_x,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*       grad_f</div>
<div class="line">   ) = 0;</div>
</div><!-- fragment --><p>Method to request the gradient of the objective function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(in) the number of variables \(x\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">x</td><td>(in) the values for the primal variables \(x\) at which the gradient \(\nabla f(x)\) is to be evaluated </td></tr>
    <tr><td class="paramname">new_x</td><td>(in) false if any evaluation method (<code>eval_*</code>) was previously called with the same values in x, true otherwise; see also TNLP::eval_f </td></tr>
    <tr><td class="paramname">grad_f</td><td>(out) array to store values of the gradient of the objective function \(\nabla f(x)\). The gradient array is in the same order as the \(x\) variables (i.e., the gradient of the objective with respect to <code>x[2]</code> should be put in <code>grad_f[2]</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false otherwise. </dd></dl>
</blockquote>
<p>In our example, we ignore the new_x flag and calculate the values for the gradient of the objective.</p>
<div class="fragment"><div class="line"><span class="comment">// return the gradient of the objective function grad_{x} f(x)</span></div>
<div class="line"><span class="keywordtype">bool</span> HS071_NLP::eval_grad_f(</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         n,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">   <span class="keywordtype">bool</span>          new_x,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*       grad_f</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">   assert(n == 4);</div>
<div class="line"> </div>
<div class="line">   grad_f[0] = x[0] * x[3] + x[3] * (x[0] + x[1] + x[2]);</div>
<div class="line">   grad_f[1] = x[0] * x[3];</div>
<div class="line">   grad_f[2] = x[0] * x[3] + 1;</div>
<div class="line">   grad_f[3] = x[0] * (x[0] + x[1] + x[2]);</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="classIpopt_1_1TNLP.html#afcfd8404b772dc4960f2d2db4e8bb382">Ipopt::TNLP::eval_g</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> eval_g(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         n,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">      <span class="keywordtype">bool</span>          new_x,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         m,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*       g</div>
<div class="line">   ) = 0;</div>
</div><!-- fragment --><p>Method to request the constraint values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(in) the number of variables \(x\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">x</td><td>(in) the values for the primal variables \(x\) at which the constraint functions \(g(x)\) are to be evaluated </td></tr>
    <tr><td class="paramname">new_x</td><td>(in) false if any evaluation method (<code>eval_*</code>) was previously called with the same values in x, true otherwise; see also TNLP::eval_f </td></tr>
    <tr><td class="paramname">m</td><td>(in) the number of constraints \(g(x)\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">g</td><td>(out) array to store constraint function values \(g(x)\), do not add or subtract the bound values \(g^L\) or \(g^U\).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false otherwise. </dd></dl>
</blockquote>
<p>In our example, we ignore the new_x flag and calculate the values of constraint functions.</p>
<div class="fragment"><div class="line"><span class="comment">// return the value of the constraints: g(x)</span></div>
<div class="line"><span class="keywordtype">bool</span> HS071_NLP::eval_g(</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         n,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">   <span class="keywordtype">bool</span>          new_x,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         m,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*       g</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">   assert(n == 4);</div>
<div class="line">   assert(m == 2);</div>
<div class="line"> </div>
<div class="line">   g[0] = x[0] * x[1] * x[2] * x[3];</div>
<div class="line">   g[1] = x[0] * x[0] + x[1] * x[1] + x[2] * x[2] + x[3] * x[3];</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="classIpopt_1_1TNLP.html#aa4162d052f69d4f9946a42feec012853">Ipopt::TNLP::eval_jac_g</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> eval_jac_g(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         n,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">      <span class="keywordtype">bool</span>          new_x,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         m,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         nele_jac,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>*        iRow,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>*        jCol,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*       values</div>
<div class="line">   ) = 0;</div>
</div><!-- fragment --><p>Method to request either the sparsity structure or the values of the Jacobian of the constraints. The Jacobian is the matrix of derivatives where the derivative of constraint function \(g_i\) with respect to variable \(x_j\) is placed in row \(i\) and column \(j\). See <a class="el" href="IMPL.html#TRIPLET">Triplet Format for Sparse Matrices</a> for a discussion of the sparse matrix format used in this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(in) the number of variables \(x\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">x</td><td>(in) first call: NULL; later calls: the values for the primal variables \(x\) at which the constraint Jacobian \(\nabla g(x)^T\) is to be evaluated </td></tr>
    <tr><td class="paramname">new_x</td><td>(in) false if any evaluation method (<code>eval_*</code>) was previously called with the same values in x, true otherwise; see also TNLP::eval_f </td></tr>
    <tr><td class="paramname">m</td><td>(in) the number of constraints \(g(x)\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">nele_jac</td><td>(in) the number of nonzero elements in the Jacobian; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">iRow</td><td>(out) first call: array of length nele_jac to store the row indices of entries in the Jacobian of the constraints; later calls: NULL </td></tr>
    <tr><td class="paramname">jCol</td><td>(out) first call: array of length nele_jac to store the column indices of entries in the Jacobian of the constraints; later calls: NULL </td></tr>
    <tr><td class="paramname">values</td><td>(out) first call: NULL; later calls: array of length nele_jac to store the values of the entries in the Jacobian of the constraints</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The arrays iRow and jCol only need to be filled once. If the iRow and jCol arguments are not NULL (first call to this function), then Ipopt expects that the sparsity structure of the Jacobian (the row and column indices only) are written into iRow and jCol. At this call, the arguments <code>x</code> and <code>values</code> will be NULL. If the arguments <code>x</code> and <code>values</code> are not NULL, then Ipopt expects that the value of the Jacobian as calculated from array <code>x</code> is stored in array <code>values</code> (using the same order as used when specifying the sparsity structure). At this call, the arguments <code>iRow</code> and <code>jCol</code> will be NULL. </dd></dl>
</blockquote>
<p>In our example, the Jacobian is actually dense, but we still specify it using the sparse format.</p>
<div class="fragment"><div class="line"><span class="comment">// return the structure or values of the Jacobian</span></div>
<div class="line"><span class="keywordtype">bool</span> HS071_NLP::eval_jac_g(</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         n,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">   <span class="keywordtype">bool</span>          new_x,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         m,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         nele_jac,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>*        iRow,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>*        jCol,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*       values</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">   assert(n == 4);</div>
<div class="line">   assert(m == 2);</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">if</span>( values == NULL )</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// return the structure of the Jacobian</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// this particular Jacobian is dense</span></div>
<div class="line">      iRow[0] = 0;</div>
<div class="line">      jCol[0] = 0;</div>
<div class="line">      iRow[1] = 0;</div>
<div class="line">      jCol[1] = 1;</div>
<div class="line">      iRow[2] = 0;</div>
<div class="line">      jCol[2] = 2;</div>
<div class="line">      iRow[3] = 0;</div>
<div class="line">      jCol[3] = 3;</div>
<div class="line">      iRow[4] = 1;</div>
<div class="line">      jCol[4] = 0;</div>
<div class="line">      iRow[5] = 1;</div>
<div class="line">      jCol[5] = 1;</div>
<div class="line">      iRow[6] = 1;</div>
<div class="line">      jCol[6] = 2;</div>
<div class="line">      iRow[7] = 1;</div>
<div class="line">      jCol[7] = 3;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">else</span></div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// return the values of the Jacobian of the constraints</span></div>
<div class="line"> </div>
<div class="line">      values[0] = x[1] * x[2] * x[3]; <span class="comment">// 0,0</span></div>
<div class="line">      values[1] = x[0] * x[2] * x[3]; <span class="comment">// 0,1</span></div>
<div class="line">      values[2] = x[0] * x[1] * x[3]; <span class="comment">// 0,2</span></div>
<div class="line">      values[3] = x[0] * x[1] * x[2]; <span class="comment">// 0,3</span></div>
<div class="line"> </div>
<div class="line">      values[4] = 2 * x[0]; <span class="comment">// 1,0</span></div>
<div class="line">      values[5] = 2 * x[1]; <span class="comment">// 1,1</span></div>
<div class="line">      values[6] = 2 * x[2]; <span class="comment">// 1,2</span></div>
<div class="line">      values[7] = 2 * x[3]; <span class="comment">// 1,3</span></div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="classIpopt_1_1TNLP.html#a26b9145267e2574c53acc284fef1c354">Ipopt::TNLP::eval_h</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> eval_h(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         n,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">      <span class="keywordtype">bool</span>          new_x,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>        obj_factor,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         m,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* lambda,</div>
<div class="line">      <span class="keywordtype">bool</span>          new_lambda,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         nele_hess,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>*        iRow,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>*        jCol,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*       values</div>
<div class="line">   )</div>
</div><!-- fragment --><p>Method to request either the sparsity structure or the values of the Hessian of the Lagrangian. The Hessian matrix that Ipopt uses is </p><p class="formulaDsp">
\[ \sigma_f \nabla^2 f(x_k) + \sum_{i=1}^m\lambda_i\nabla^2 g_i(x_k) \]
</p>
<p> for the given values for \(x\), \(\sigma_f\), and \(\lambda\). See <a class="el" href="IMPL.html#TRIPLET">Triplet Format for Sparse Matrices</a> for a discussion of the sparse matrix format used in this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>(in) the number of variables \(x\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">x</td><td>(in) first call: NULL; later calls: the values for the primal variables \(x\) at which the Hessian is to be evaluated </td></tr>
    <tr><td class="paramname">new_x</td><td>(in) false if any evaluation method (<code>eval_*</code>) was previously called with the same values in x, true otherwise; see also TNLP::eval_f </td></tr>
    <tr><td class="paramname">obj_factor</td><td>(in) factor \(\sigma_f\) in front of the objective term in the Hessian </td></tr>
    <tr><td class="paramname">m</td><td>(in) the number of constraints \(g(x)\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">lambda</td><td>(in) the values for the constraint multipliers \(\lambda\) at which the Hessian is to be evaluated </td></tr>
    <tr><td class="paramname">new_lambda</td><td>(in) false if any evaluation method was previously called with the same values in lambda, true otherwise </td></tr>
    <tr><td class="paramname">nele_hess</td><td>(in) the number of nonzero elements in the Hessian; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">iRow</td><td>(out) first call: array of length nele_hess to store the row indices of entries in the Hessian; later calls: NULL </td></tr>
    <tr><td class="paramname">jCol</td><td>(out) first call: array of length nele_hess to store the column indices of entries in the Hessian; later calls: NULL </td></tr>
    <tr><td class="paramname">values</td><td>(out) first call: NULL; later calls: array of length nele_hess to store the values of the entries in the Hessian</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The arrays iRow and jCol only need to be filled once. If the iRow and jCol arguments are not NULL (first call to this function), then Ipopt expects that the sparsity structure of the Hessian (the row and column indices only) are written into iRow and jCol. At this call, the arguments <code>x</code>, <code>lambda</code>, and <code>values</code> will be NULL. If the arguments <code>x</code>, <code>lambda</code>, and <code>values</code> are not NULL, then Ipopt expects that the value of the Hessian as calculated from arrays <code>x</code> and <code>lambda</code> are stored in array <code>values</code> (using the same order as used when specifying the sparsity structure). At this call, the arguments <code>iRow</code> and <code>jCol</code> will be NULL.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>As this matrix is symmetric, Ipopt expects that only the lower diagonal entries are specified.</dd></dl>
<p>A default implementation is provided, in case the user wants to set quasi-Newton approximations to estimate the second derivatives and doesn't not need to implement this method. </p>
</blockquote>
<p>In our example, the Hessian is dense, but we still specify it using the sparse matrix format. Because the Hessian is symmetric, we only need to specify the lower left corner.</p>
<div class="fragment"><div class="line"><span class="comment">//return the structure or values of the Hessian</span></div>
<div class="line"><span class="keywordtype">bool</span> HS071_NLP::eval_h(</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         n,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x,</div>
<div class="line">   <span class="keywordtype">bool</span>          new_x,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>        obj_factor,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         m,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* lambda,</div>
<div class="line">   <span class="keywordtype">bool</span>          new_lambda,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>         nele_hess,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>*        iRow,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>*        jCol,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*       values</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">   assert(n == 4);</div>
<div class="line">   assert(m == 2);</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">if</span>( values == NULL )</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// return the structure. This is a symmetric matrix, fill the lower left</span></div>
<div class="line">      <span class="comment">// triangle only.</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// the hessian for this problem is actually dense</span></div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a> idx = 0;</div>
<div class="line">      <span class="keywordflow">for</span>( <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a> row = 0; row &lt; 4; row++ )</div>
<div class="line">      {</div>
<div class="line">         <span class="keywordflow">for</span>( <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a> col = 0; col &lt;= row; col++ )</div>
<div class="line">         {</div>
<div class="line">            iRow[idx] = row;</div>
<div class="line">            jCol[idx] = col;</div>
<div class="line">            idx++;</div>
<div class="line">         }</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      assert(idx == nele_hess);</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">else</span></div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// return the values. This is a symmetric matrix, fill the lower left</span></div>
<div class="line">      <span class="comment">// triangle only</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// fill the objective portion</span></div>
<div class="line">      values[0] = obj_factor * (2 * x[3]); <span class="comment">// 0,0</span></div>
<div class="line"> </div>
<div class="line">      values[1] = obj_factor * (x[3]);     <span class="comment">// 1,0</span></div>
<div class="line">      values[2] = 0.;                      <span class="comment">// 1,1</span></div>
<div class="line"> </div>
<div class="line">      values[3] = obj_factor * (x[3]);     <span class="comment">// 2,0</span></div>
<div class="line">      values[4] = 0.;                      <span class="comment">// 2,1</span></div>
<div class="line">      values[5] = 0.;                      <span class="comment">// 2,2</span></div>
<div class="line"> </div>
<div class="line">      values[6] = obj_factor * (2 * x[0] + x[1] + x[2]); <span class="comment">// 3,0</span></div>
<div class="line">      values[7] = obj_factor * (x[0]);                   <span class="comment">// 3,1</span></div>
<div class="line">      values[8] = obj_factor * (x[0]);                   <span class="comment">// 3,2</span></div>
<div class="line">      values[9] = 0.;                                    <span class="comment">// 3,3</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// add the portion for the first constraint</span></div>
<div class="line">      values[1] += lambda[0] * (x[2] * x[3]); <span class="comment">// 1,0</span></div>
<div class="line"> </div>
<div class="line">      values[3] += lambda[0] * (x[1] * x[3]); <span class="comment">// 2,0</span></div>
<div class="line">      values[4] += lambda[0] * (x[0] * x[3]); <span class="comment">// 2,1</span></div>
<div class="line"> </div>
<div class="line">      values[6] += lambda[0] * (x[1] * x[2]); <span class="comment">// 3,0</span></div>
<div class="line">      values[7] += lambda[0] * (x[0] * x[2]); <span class="comment">// 3,1</span></div>
<div class="line">      values[8] += lambda[0] * (x[0] * x[1]); <span class="comment">// 3,2</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// add the portion for the second constraint</span></div>
<div class="line">      values[0] += lambda[1] * 2; <span class="comment">// 0,0</span></div>
<div class="line"> </div>
<div class="line">      values[2] += lambda[1] * 2; <span class="comment">// 1,1</span></div>
<div class="line"> </div>
<div class="line">      values[5] += lambda[1] * 2; <span class="comment">// 2,2</span></div>
<div class="line"> </div>
<div class="line">      values[9] += lambda[1] * 2; <span class="comment">// 3,3</span></div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="classIpopt_1_1TNLP.html#a3debb40a1dc203d3d53a93ccc7ea928d">Ipopt::TNLP::finalize_solution</a></p>
<blockquote class="doxtable">
<p>This is the only method that is not mentioned in the beginning of this section.</p>
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> finalize_solution(</div>
<div class="line">      <a class="code" href="namespaceIpopt.html#a53a5dc5f64f568252ba7bb7385e7f834">SolverReturn</a>               status,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                      n,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*              x,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*              z_L,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*              z_U,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                      m,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*              g,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*              lambda,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     obj_value,</div>
<div class="line">      <span class="keyword">const</span> IpoptData*           ip_data,</div>
<div class="line">      IpoptCalculatedQuantities* ip_cq</div>
<div class="line">   ) = 0;</div>
</div><!-- fragment --><p>This method is called when the algorithm has finished (successfully or not) so the TNLP can digest the outcome, e.g., store/write the solution, if any. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>(in) gives the status of the algorithm<ul>
<li>SUCCESS: Algorithm terminated successfully at a locally optimal point, satisfying the convergence tolerances (can be specified by options).</li>
<li>MAXITER_EXCEEDED: Maximum number of iterations exceeded (can be specified by an option).</li>
<li>CPUTIME_EXCEEDED: Maximum number of CPU seconds exceeded (can be specified by an option).</li>
<li>STOP_AT_TINY_STEP: Algorithm proceeds with very little progress.</li>
<li>STOP_AT_ACCEPTABLE_POINT: Algorithm stopped at a point that was converged, not to "desired" tolerances, but to "acceptable" tolerances (see the acceptable-... options).</li>
<li>LOCAL_INFEASIBILITY: Algorithm converged to a point of local infeasibility. Problem may be infeasible.</li>
<li>USER_REQUESTED_STOP: The user call-back function TNLP::intermediate_callback returned false, i.e., the user code requested a premature termination of the optimization.</li>
<li>DIVERGING_ITERATES: It seems that the iterates diverge.</li>
<li>RESTORATION_FAILURE: Restoration phase failed, algorithm doesn't know how to proceed.</li>
<li>ERROR_IN_STEP_COMPUTATION: An unrecoverable error occurred while Ipopt tried to compute the search direction.</li>
<li>INVALID_NUMBER_DETECTED: Algorithm received an invalid number (such as NaN or Inf) from the NLP; see also option check_derivatives_for_nan_inf).</li>
<li>INTERNAL_ERROR: An unknown internal error occurred. </li>
</ul>
</td></tr>
    <tr><td class="paramname">n</td><td>(in) the number of variables \(x\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">x</td><td>(in) the final values for the primal variables </td></tr>
    <tr><td class="paramname">z_L</td><td>(in) the final values for the lower bound multipliers </td></tr>
    <tr><td class="paramname">z_U</td><td>(in) the final values for the upper bound multipliers </td></tr>
    <tr><td class="paramname">m</td><td>(in) the number of constraints \(g(x)\) in the problem; it will have the same value that was specified in TNLP::get_nlp_info </td></tr>
    <tr><td class="paramname">g</td><td>(in) the final values of the constraint functions </td></tr>
    <tr><td class="paramname">lambda</td><td>(in) the final values of the constraint multipliers </td></tr>
    <tr><td class="paramname">obj_value</td><td>(in) the final value of the objective function </td></tr>
    <tr><td class="paramname">ip_data</td><td>(in) provided for expert users </td></tr>
    <tr><td class="paramname">ip_cq</td><td>(in) provided for expert users </td></tr>
  </table>
  </dd>
</dl>
</blockquote>
<p>In our example, we will print the values of some of the variables to the screen.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> HS071_NLP::finalize_solution(</div>
<div class="line">   <a class="code" href="namespaceIpopt.html#a53a5dc5f64f568252ba7bb7385e7f834">SolverReturn</a>               status,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                      n,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*              x,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*              z_L,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*              z_U,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                      m,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*              g,</div>
<div class="line">   <span class="keyword">const</span> <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>*              lambda,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     obj_value,</div>
<div class="line">   <span class="keyword">const</span> IpoptData*           ip_data,</div>
<div class="line">   IpoptCalculatedQuantities* ip_cq</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// here is where we would store the solution to variables, or write to a file, etc</span></div>
<div class="line">   <span class="comment">// so we could use the solution.</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// For this example, we write the solution to the console</span></div>
<div class="line">   std::cout &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Solution of the primal variables, x&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">   <span class="keywordflow">for</span>( <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a> i = 0; i &lt; n; i++ )</div>
<div class="line">   {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;x[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; x[i] &lt;&lt; std::endl;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   std::cout &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Solution of the bound multipliers, z_L and z_U&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">   <span class="keywordflow">for</span>( <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a> i = 0; i &lt; n; i++ )</div>
<div class="line">   {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;z_L[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; z_L[i] &lt;&lt; std::endl;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">for</span>( <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a> i = 0; i &lt; n; i++ )</div>
<div class="line">   {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;z_U[&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;] = &quot;</span> &lt;&lt; z_U[i] &lt;&lt; std::endl;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   std::cout &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Objective value&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;f(x*) = &quot;</span> &lt;&lt; obj_value &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">   std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;Final value of the constraints:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">   <span class="keywordflow">for</span>( <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a> i = 0; i &lt; m; i++ )</div>
<div class="line">   {</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;g(&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;) = &quot;</span> &lt;&lt; g[i] &lt;&lt; std::endl;</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p> This is all that is required for our HS071_NLP class and the coding of the problem representation.</p>
<h3><a class="anchor" id="INTERFACE_CPP_MAIN"></a>
Coding the Executable</h3>
<p>Now that we have a problem representation, the HS071_NLP class, we need to code the main function that will call Ipopt and ask Ipopt to find a solution.</p>
<p>Here, we must create an instance of our problem (HS071_NLP), create an instance of the Ipopt solver (<a class="el" href="classIpopt_1_1IpoptApplication.html" title="This is the main application class for making calls to Ipopt.">Ipopt::IpoptApplication</a>), initialize it, and ask the solver to find a solution. We always use the <a class="el" href="classIpopt_1_1SmartPtr.html" title="Template class for Smart Pointers.">Ipopt::SmartPtr</a> template class instead of raw C++ pointers when creating and passing Ipopt objects. To find out more information about smart pointers and the SmartPtr implementation used in Ipopt, see <a class="el" href="IMPL.html#SMARTPTR">The Smart Pointer Implementation: SmartPtr&lt;T&gt;</a>.</p>
<p>Create the file <code>MyExample.cpp</code> in the <code>MyExample</code> directory. Include the header files <code>HS071_NLP.hpp</code> and <code><a class="el" href="IpIpoptApplication_8hpp.html">IpIpoptApplication.hpp</a></code>, tell the compiler to use the <a class="el" href="namespaceIpopt.html" title="This file contains a base class for all exceptions and a set of macros to help with exceptions.">Ipopt</a> namespace, and implement the main function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="IpIpoptApplication_8hpp.html">IpIpoptApplication.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;hs071_nlp.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceIpopt.html">Ipopt</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(</div>
<div class="line">   <span class="keywordtype">int</span>    <span class="comment">/*argv*/</span>,</div>
<div class="line">   <span class="keywordtype">char</span>** <span class="comment">/*argc*/</span></div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// Create a new instance of your nlp</span></div>
<div class="line">   <span class="comment">//  (use a SmartPtr, not raw)</span></div>
<div class="line">   <a class="code" href="classIpopt_1_1SmartPtr.html">SmartPtr&lt;TNLP&gt;</a> mynlp = <span class="keyword">new</span> HS071_NLP();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Create a new instance of IpoptApplication</span></div>
<div class="line">   <span class="comment">//  (use a SmartPtr, not raw)</span></div>
<div class="line">   <span class="comment">// We are using the factory, since this allows us to compile this</span></div>
<div class="line">   <span class="comment">// example with an Ipopt Windows DLL</span></div>
<div class="line">   <a class="code" href="classIpopt_1_1SmartPtr.html">SmartPtr&lt;IpoptApplication&gt;</a> app = <a class="code" href="IpIpoptApplication_8hpp.html#aa84adcc7d6c00fda4bac0c05db27dd0d">IpoptApplicationFactory</a>();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Change some options</span></div>
<div class="line">   <span class="comment">// Note: The following choices are only examples, they might not be</span></div>
<div class="line">   <span class="comment">//       suitable for your optimization problem.</span></div>
<div class="line">   app-&gt;<a class="code" href="classIpopt_1_1IpoptApplication.html#a86039c4a135ffafbd5daf4d0f61ee83f">Options</a>()-&gt;SetNumericValue(<span class="stringliteral">&quot;tol&quot;</span>, 3.82e-6);</div>
<div class="line">   app-&gt;<a class="code" href="classIpopt_1_1IpoptApplication.html#a86039c4a135ffafbd5daf4d0f61ee83f">Options</a>()-&gt;SetStringValue(<span class="stringliteral">&quot;mu_strategy&quot;</span>, <span class="stringliteral">&quot;adaptive&quot;</span>);</div>
<div class="line">   app-&gt;<a class="code" href="classIpopt_1_1IpoptApplication.html#a86039c4a135ffafbd5daf4d0f61ee83f">Options</a>()-&gt;SetStringValue(<span class="stringliteral">&quot;output_file&quot;</span>, <span class="stringliteral">&quot;ipopt.out&quot;</span>);</div>
<div class="line">   <span class="comment">// The following overwrites the default name (ipopt.opt) of the options file</span></div>
<div class="line">   <span class="comment">// app-&gt;Options()-&gt;SetStringValue(&quot;option_file_name&quot;, &quot;hs071.opt&quot;);</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Initialize the IpoptApplication and process the options</span></div>
<div class="line">   <a class="code" href="IpReturnCodes__inc_8h.html#ab542e0b1ca364a9b7525a876ffdae7d7">ApplicationReturnStatus</a> status;</div>
<div class="line">   status = app-&gt;<a class="code" href="classIpopt_1_1IpoptApplication.html#ac806999950a0c1add56baac203bec6d0">Initialize</a>();</div>
<div class="line">   <span class="keywordflow">if</span>( status != <a class="code" href="IpReturnCodes__inc_8h.html#ab542e0b1ca364a9b7525a876ffdae7d7a98f85390ead47dbab52ac6d20aef904b">Solve_Succeeded</a> )</div>
<div class="line">   {</div>
<div class="line">      std::cout &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;*** Error during initialization!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) status;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Ask Ipopt to solve the problem</span></div>
<div class="line">   status = app-&gt;<a class="code" href="classIpopt_1_1IpoptApplication.html#adc99b9f91f353063dd0a984bc3e33a82">OptimizeTNLP</a>(mynlp);</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">if</span>( status == <a class="code" href="IpReturnCodes__inc_8h.html#ab542e0b1ca364a9b7525a876ffdae7d7a98f85390ead47dbab52ac6d20aef904b">Solve_Succeeded</a> )</div>
<div class="line">   {</div>
<div class="line">      std::cout &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;*** The problem solved!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">else</span></div>
<div class="line">   {</div>
<div class="line">      std::cout &lt;&lt; std::endl &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;*** The problem FAILED!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// As the SmartPtrs go out of scope, the reference count</span></div>
<div class="line">   <span class="comment">// will be decremented and the objects will automatically</span></div>
<div class="line">   <span class="comment">// be deleted.</span></div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) status;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The first line of code in <code>main()</code> creates an instance of HS071_NLP. We then create an instance of the Ipopt solver, <a class="el" href="classIpopt_1_1IpoptApplication.html" title="This is the main application class for making calls to Ipopt.">Ipopt::IpoptApplication</a>. You could use <code>new</code> to create a new application object, but if you want to make sure that your code would also work with a Windows DLL, you need to use the factory, as done in the example above. The call to <code>app-&gt;Initialize(...)</code> will initialize that object and process the options (particularly the output related options). The call to <code>app-&gt;OptimizeTNLP(...)</code> will run Ipopt and try to solve the problem. By default, Ipopt will write its progress to the console, and return the SolverReturn status.</p>
<h3><a class="anchor" id="INTERFACE_CPP_COMPILE"></a>
Compiling and Testing the Example</h3>
<p>Our next task is to compile and test the code. If you are familiar with the compiler and linker used on your system, you can build the code, telling the linker about the necessary libraries, as obtained via <code>pkg-config --lflags ipopt</code>. The build system already created a sample makefile. Copy <code>Ipopt/examples/hs071_cpp/Makefile</code> into your <code>MyExample</code> directory. This makefile was created for the <code>hs071_cpp</code> code, but it can be easily modified for your example problem. Edit the file, making the following changes:</p>
<ul>
<li>change the EXE variable<pre class="fragment">EXE = my_example </pre></li>
<li>change the OBJS variable<pre class="fragment">OBJS = HS071_NLP.o MyExample.o </pre></li>
</ul>
<p>The code should compile easily with </p><pre class="fragment">$ make
</pre><p>Now run the executable with </p><pre class="fragment">$ ./my_example
</pre><p> and you should see output resembling the following: </p><pre class="fragment">******************************************************************************
This program contains Ipopt, a library for large-scale nonlinear optimization.
 Ipopt is released as open source code under the Eclipse Public License (EPL).
         For more information visit https://github.com/coin-or/Ipopt
******************************************************************************

Number of nonzeros in equality constraint Jacobian...:        4
Number of nonzeros in inequality constraint Jacobian.:        4
Number of nonzeros in Lagrangian Hessian.............:       10

Total number of variables............................:        4
                     variables with only lower bounds:        0
                variables with lower and upper bounds:        4
                     variables with only upper bounds:        0
Total number of equality constraints.................:        1
Total number of inequality constraints...............:        1
        inequality constraints with only lower bounds:        1
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:        0

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.6109693e+01 1.12e+01 5.28e-01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.7410406e+01 8.38e-01 2.25e+01  -0.3 7.97e-01    -  3.19e-01 1.00e+00f  1
   2  1.8001613e+01 1.06e-02 4.96e+00  -0.3 5.60e-02   2.0 9.97e-01 1.00e+00h  1
   3  1.7199482e+01 9.04e-02 4.24e-01  -1.0 9.91e-01    -  9.98e-01 1.00e+00f  1
   4  1.6940955e+01 2.09e-01 4.58e-02  -1.4 2.88e-01    -  9.66e-01 1.00e+00h  1
   5  1.7003411e+01 2.29e-02 8.42e-03  -2.9 7.03e-02    -  9.68e-01 1.00e+00h  1
   6  1.7013974e+01 2.59e-04 8.65e-05  -4.5 6.22e-03    -  1.00e+00 1.00e+00h  1
   7  1.7014017e+01 2.26e-07 5.71e-08  -8.0 1.43e-04    -  1.00e-00 1.00e+00h  1
   8  1.7014017e+01 4.62e-14 9.09e-14  -8.0 6.95e-08    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 8

Number of objective function evaluations             = 9
Number of objective gradient evaluations             = 9
Number of equality constraint evaluations            = 9
Number of inequality constraint evaluations          = 9
Number of equality constraint Jacobian evaluations   = 9
Number of inequality constraint Jacobian evaluations = 9
Number of Lagrangian Hessian evaluations             = 8
Total CPU secs in IPOPT (w/o function evaluations)   =      0.220
Total CPU secs in NLP function evaluations           =      0.000

EXIT: Optimal Solution Found.


Solution of the primal variables, x
x[0] = 1.000000e+00
x[1] = 4.743000e+00
x[2] = 3.821150e+00
x[3] = 1.379408e+00


Solution of the bound multipliers, z_L and z_U
z_L[0] = 1.087871e+00
z_L[1] = 2.428776e-09
z_L[2] = 3.222413e-09
z_L[3] = 2.396076e-08
z_U[0] = 2.272727e-09
z_U[1] = 3.537314e-08
z_U[2] = 7.711676e-09
z_U[3] = 2.510890e-09


Objective value
f(x*) = 1.701402e+01


*** The problem solved!
</pre><p>This completes the basic C++ tutorial, but see <a class="el" href="OUTPUT.html">Ipopt Output</a> for explanation on the standard console output of Ipopt and <a class="el" href="OPTIONS.html">Ipopt Options</a> for information about the use of options to customize the behavior of Ipopt.</p>
<p>The <code>Ipopt/examples/ScalableProblems</code> directory contains other NLP problems coded in C++.</p>
<h3><a class="anchor" id="INTERFACE_CPP_ADDITIONAL"></a>
Additional methods in TNLP</h3>
<p>The following methods are available for additional features that are not explained in the example. Default implementations for those methods are provided, so that a user can safely ignore them, unless she wants to make use of those features. From these features, only the intermediate callback is already available in the C and Fortran interfaces.</p>
<p><a class="el" href="classIpopt_1_1TNLP.html#a2f962a4c43464adb7928771af84503d6">Ipopt::TNLP::intermediate_callback</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> intermediate_callback(</div>
<div class="line">      <a class="code" href="IpReturnCodes__inc_8h.html#a5daff61568f9909c518fb61116260387">AlgorithmMode</a>              mode,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                      iter,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     obj_value,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     inf_pr,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     inf_du,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     mu,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     d_norm,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     regularization_size,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     alpha_du,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     alpha_pr,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                      ls_trials,</div>
<div class="line">      <span class="keyword">const</span> IpoptData*           ip_data,</div>
<div class="line">      IpoptCalculatedQuantities* ip_cq</div>
<div class="line">   )</div>
</div><!-- fragment --><p>Intermediate Callback method for the user. This method is called once per iteration (during the convergence check), and can be used to obtain information about the optimization status while Ipopt solves the problem, and also to request a premature termination.</p>
<p>The information provided by the entities in the argument list correspond to what Ipopt prints in the iteration summary (see also <a class="el" href="OUTPUT.html">Ipopt Output</a>). Further information can be obtained from the ip_data and ip_cq objects. The current iterate and violations of feasibility and optimality can be accessed via the methods <a class="el" href="classIpopt_1_1TNLP.html#a8b8a5be340562ea82358a7b6d2bb0969" title="Get primal and dual variable values of the current iterate.">Ipopt::TNLP::get_curr_iterate()</a> and <a class="el" href="classIpopt_1_1TNLP.html#a723401f01da3ee61d4f51a2e05d9b2f9" title="Get primal and dual infeasibility of the current iterate.">Ipopt::TNLP::get_curr_violations()</a>. These methods translate values for the <em>internal representation</em> of the problem from <code>ip_data</code> and <code>ip_cq</code> objects into the TNLP representation.</p>
<dl class="section return"><dt>Returns</dt><dd>If this method returns false, Ipopt will terminate with the User_Requested_Stop status.</dd></dl>
<p>It is not required to implement (overload) this method. The default implementation always returns true. </p>
</blockquote>
<p>In our example, we optionally print the current iterate and its violation of optimality conditions to the screen.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> HS071_NLP::intermediate_callback(</div>
<div class="line">   <a class="code" href="IpReturnCodes__inc_8h.html#a5daff61568f9909c518fb61116260387">AlgorithmMode</a>              mode,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                      iter,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     obj_value,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     inf_pr,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     inf_du,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     mu,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     d_norm,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     regularization_size,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     alpha_du,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>                     alpha_pr,</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                      ls_trials,</div>
<div class="line">   <span class="keyword">const</span> IpoptData*           ip_data,</div>
<div class="line">   IpoptCalculatedQuantities* ip_cq</div>
<div class="line">)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">if</span>( !printiterate_ )</div>
<div class="line">   {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> x[4];</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> x_L_viol[4];</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> x_U_viol[4];</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> z_L[4];</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> z_U[4];</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> compl_x_L[4];</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> compl_x_U[4];</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> grad_lag_x[4];</div>
<div class="line"> </div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> g[2];</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> lambda[2];</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> constraint_violation[2];</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a> compl_g[2];</div>
<div class="line"> </div>
<div class="line">   <span class="keywordtype">bool</span> have_iter = get_curr_iterate(ip_data, ip_cq, <span class="keyword">false</span>, 4, x, z_L, z_U, 2, g, lambda);</div>
<div class="line">   <span class="keywordtype">bool</span> have_viol = get_curr_violations(ip_data, ip_cq, <span class="keyword">false</span>, 4, x_L_viol, x_U_viol, compl_x_L, compl_x_U, grad_lag_x, 2, constraint_violation, compl_g);</div>
<div class="line"> </div>
<div class="line">   printf(<span class="stringliteral">&quot;Current iterate:\n&quot;</span>);</div>
<div class="line">   printf(<span class="stringliteral">&quot;  %-12s %-12s %-12s %-12s %-12s %-12s %-12s\n&quot;</span>, <span class="stringliteral">&quot;x&quot;</span>, <span class="stringliteral">&quot;z_L&quot;</span>, <span class="stringliteral">&quot;z_U&quot;</span>, <span class="stringliteral">&quot;bound_viol&quot;</span>, <span class="stringliteral">&quot;compl_x_L&quot;</span>, <span class="stringliteral">&quot;compl_x_U&quot;</span>, <span class="stringliteral">&quot;grad_lag_x&quot;</span>);</div>
<div class="line">   <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; 4; ++i )</div>
<div class="line">   {</div>
<div class="line">      <span class="keywordflow">if</span>( have_iter )</div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot;  %-12g %-12g %-12g&quot;</span>, x[i], z_L[i], z_U[i]);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot;  %-12s %-12s %-12s&quot;</span>, <span class="stringliteral">&quot;n/a&quot;</span>, <span class="stringliteral">&quot;n/a&quot;</span>, <span class="stringliteral">&quot;n/a&quot;</span>);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span>( have_viol )</div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot; %-12g %-12g %-12g %-12g\n&quot;</span>, x_L_viol[i] &gt; x_U_viol[i] ? x_L_viol[i] : x_U_viol[i], compl_x_L[i], compl_x_U[i], grad_lag_x[i]);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot; %-12s %-12s %-12s %-12s\n&quot;</span>, <span class="stringliteral">&quot;n/a&quot;</span>, <span class="stringliteral">&quot;n/a&quot;</span>, <span class="stringliteral">&quot;n/a&quot;</span>, <span class="stringliteral">&quot;n/a&quot;</span>);</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   printf(<span class="stringliteral">&quot;  %-12s %-12s %-12s %-12s\n&quot;</span>, <span class="stringliteral">&quot;g(x)&quot;</span>, <span class="stringliteral">&quot;lambda&quot;</span>, <span class="stringliteral">&quot;constr_viol&quot;</span>, <span class="stringliteral">&quot;compl_g&quot;</span>);</div>
<div class="line">   <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; 2; ++i )</div>
<div class="line">   {</div>
<div class="line">      <span class="keywordflow">if</span>( have_iter )</div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot;  %-12g %-12g&quot;</span>, g[i], lambda[i]);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot;  %-12s %-12s&quot;</span>, <span class="stringliteral">&quot;n/a&quot;</span>, <span class="stringliteral">&quot;n/a&quot;</span>);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span>( have_viol )</div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot; %-12g %-12g\n&quot;</span>, constraint_violation[i], compl_g[i]);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot; %-12s %-12s\n&quot;</span>, <span class="stringliteral">&quot;n/a&quot;</span>, <span class="stringliteral">&quot;n/a&quot;</span>);</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="classIpopt_1_1TNLP.html#a3e840dddefbe48a048d213bd02b39854">Ipopt::TNLP::get_scaling_parameters</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_scaling_parameters(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>&amp; obj_scaling,</div>
<div class="line">      <span class="keywordtype">bool</span>&amp;   use_x_scaling,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>   n,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* x_scaling,</div>
<div class="line">      <span class="keywordtype">bool</span>&amp;   use_g_scaling,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>   m,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a>* g_scaling</div>
<div class="line">   )</div>
</div><!-- fragment --><p>Method to request scaling parameters. This is only called if the options are set to retrieve user scaling, that is, if nlp_scaling_method is chosen as "user-scaling". The method should provide scaling factors for the objective function as well as for the optimization variables and/or constraints. The return value should be true, unless an error occurred, and the program is to be aborted.</p>
<p>The value returned in obj_scaling determines, how Ipopt should internally scale the objective function. For example, if this number is chosen to be 10, then Ipopt solves internally an optimization problem that has 10 times the value of the original objective function provided by the TNLP. In particular, if this value is negative, then Ipopt will maximize the objective function instead of minimizing it.</p>
<p>The scaling factors for the variables can be returned in x_scaling, which has the same length as x in the other TNLP methods, and the factors are ordered like x. use_x_scaling needs to be set to true, if Ipopt should scale the variables. If it is false, no internal scaling of the variables is done. Similarly, the scaling factors for the constraints can be returned in g_scaling, and this scaling is activated by setting use_g_scaling to true.</p>
<p>As a guideline, we suggest to scale the optimization problem (either directly in the original formulation, or after using scaling factors) so that all sensitivities, i.e., all non-zero first partial derivatives, are typically of the order 0.1-10. </p>
</blockquote>
<p><a class="el" href="classIpopt_1_1TNLP.html#a015506564afc611060f4416dbb08aa4d">Ipopt::TNLP::get_number_of_nonlinear_variables</a></p>
<blockquote class="doxtable">
<p>This method is called only if the <a class="el" href="SPECIALS.html#QUASI_NEWTON">quasi-Newton approximation</a> is selected.</p>
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a> get_number_of_nonlinear_variables()</div>
</div><!-- fragment --><p>Return the number of variables that appear nonlinearly in the objective function or in at least one constraint function. If -1 is returned as number of nonlinear variables, Ipopt assumes that all variables are nonlinear. Otherwise, it calls get_list_of_nonlinear_variables with an array into which the indices of the nonlinear variables should be written - the array has the length num_nonlin_vars, which is identical with the return value of get_number_of_nonlinear_variables(). It is assumed that the indices are counted starting with 1 in the FORTRAN_STYLE, and 0 for the C_STYLE.</p>
<p>The default implementation returns -1, i.e., all variables are assumed to be nonlinear. </p>
</blockquote>
<p><a class="el" href="classIpopt_1_1TNLP.html#a9bb5f16cdc2754d1667749268fb1308c">Ipopt::TNLP::get_list_of_nonlinear_variables</a></p>
<blockquote class="doxtable">
<p>This method is called only if the <a class="el" href="SPECIALS.html#QUASI_NEWTON">quasi-Newton approximation</a> is selected.</p>
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_list_of_nonlinear_variables(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>  num_nonlin_vars,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>* pos_nonlin_vars</div>
<div class="line">   )</div>
</div><!-- fragment --><p>Return the indices of all nonlinear variables. This method is called only if limited-memory quasi-Newton option is used and get_number_of_nonlinear_variables() returned a positive number. This number is provided in parameter num_nonlin_var.</p>
<p>The method must store the indices of all nonlinear variables in pos_nonlin_vars, where the numbering starts with 0 order 1, depending on the numbering style determined in get_nlp_info. </p>
</blockquote>
<p><a class="el" href="classIpopt_1_1TNLP.html#a8edc60e43bf77aba5e8fd221ea94bf14">Ipopt::TNLP::get_variables_linearity</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_variables_linearity(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>          n,</div>
<div class="line">      LinearityType* var_types</div>
<div class="line">   )</div>
</div><!-- fragment --><p>Method to request the variables linearity. This method is never called by Ipopt, but is used by Bonmin to get information about which variables occur only in linear terms. Ipopt passes the array var_types of length at least n, which should be filled with the appropriate linearity type of the variables (TNLP::LINEAR or TNLP::NON_LINEAR).</p>
<p>The default implementation just returns false and does not fill the array. </p>
</blockquote>
<p><a class="el" href="classIpopt_1_1TNLP.html#a46f061f2dbf1c1692b7822144b7c5536">Ipopt::TNLP::get_constraints_linearity</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_constraints_linearity(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>          m,</div>
<div class="line">      LinearityType* const_types</div>
<div class="line">   )</div>
</div><!-- fragment --><p>Method to request the constraints linearity. This method is never called by Ipopt, but is used by Bonmin to get information about which constraints are linear. Ipopt passes the array const_types of size m, which should be filled with the appropriate linearity type of the constraints (TNLP::LINEAR or TNLP::NON_LINEAR).</p>
<p>The default implementation just returns false and does not fill the array. </p>
</blockquote>
<p><a class="el" href="classIpopt_1_1TNLP.html#adb231e0be2a935a9a683349429f6890e">Ipopt::TNLP::get_var_con_metadata</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_var_con_metadata(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                   n,</div>
<div class="line">      <a class="code" href="namespaceIpopt.html#a93d1b2b94faf16ee2c06be07b74c2869">StringMetaDataMapType</a>&amp;  var_string_md,</div>
<div class="line">      <a class="code" href="namespaceIpopt.html#a7b95940bef97320ac5a3635114ac6114">IntegerMetaDataMapType</a>&amp; var_integer_md,</div>
<div class="line">      <a class="code" href="namespaceIpopt.html#a08458195ba30ac6f9e88a2a48c87df52">NumericMetaDataMapType</a>&amp; var_numeric_md,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                   m,</div>
<div class="line">      <a class="code" href="namespaceIpopt.html#a93d1b2b94faf16ee2c06be07b74c2869">StringMetaDataMapType</a>&amp;  con_string_md,</div>
<div class="line">      <a class="code" href="namespaceIpopt.html#a7b95940bef97320ac5a3635114ac6114">IntegerMetaDataMapType</a>&amp; con_integer_md,</div>
<div class="line">      <a class="code" href="namespaceIpopt.html#a08458195ba30ac6f9e88a2a48c87df52">NumericMetaDataMapType</a>&amp; con_numeric_md</div>
<div class="line">   )</div>
</div><!-- fragment --><p>Method to request meta data for the variables and the constraints. This method is used to pass meta data about variables or constraints to Ipopt. The data can be either of integer, numeric, or string type. Ipopt passes this data on to its internal problem representation. The meta data type is a std::map with std::string as key type and a std::vector as value type. So far, Ipopt itself makes only use of string meta data under the key idx_names. With this key, variable and constraint names can be passed to Ipopt, which are shown when printing internal vector or matrix data structures if Ipopt is run with a high value for the option. This allows a user to identify the original variables and constraints corresponding to Ipopt's internal problem representation.</p>
<p>If this method is not overloaded, the default implementation does not set any meta data and returns false. </p>
</blockquote>
<p><a class="el" href="classIpopt_1_1TNLP.html#a729711b5af6b46e409a3bc34c832a9c5">Ipopt::TNLP::finalize_metadata</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">void</span> finalize_metadata(</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                         n,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceIpopt.html#a93d1b2b94faf16ee2c06be07b74c2869">StringMetaDataMapType</a>&amp;  var_string_md,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceIpopt.html#a7b95940bef97320ac5a3635114ac6114">IntegerMetaDataMapType</a>&amp; var_integer_md,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceIpopt.html#a08458195ba30ac6f9e88a2a48c87df52">NumericMetaDataMapType</a>&amp; var_numeric_md,</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a>                         m,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceIpopt.html#a93d1b2b94faf16ee2c06be07b74c2869">StringMetaDataMapType</a>&amp;  con_string_md,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceIpopt.html#a7b95940bef97320ac5a3635114ac6114">IntegerMetaDataMapType</a>&amp; con_integer_md,</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceIpopt.html#a08458195ba30ac6f9e88a2a48c87df52">NumericMetaDataMapType</a>&amp; con_numeric_md</div>
<div class="line">   )</div>
</div><!-- fragment --><p>This method returns any metadata collected during the run of the algorithm. This method is called just before finalize_solution is called. The returned data includes the metadata provided by TNLP::get_var_con_metadata. Each metadata can be of type string, integer, or numeric. It can be associated to either the variables or the constraints. The metadata that was associated with the primal variable vector is stored in <code>var_..._md</code>. The metadata associated with the constraint multipliers is stored in <code>con_..._md</code>. The metadata associated with the bound multipliers is stored in <code>var_..._md</code>, with the suffixes "_z_L", and "_z_U", denoting lower and upper bounds.</p>
<p>If the user doesn't overload this method in her implementation of the class derived from TNLP, the default implementation does nothing. </p>
</blockquote>
<p><a class="el" href="classIpopt_1_1TNLP.html#a273b8be28d2a0a805489cd8903aac1c6">Ipopt::TNLP::get_warm_start_iterate</a></p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_warm_start_iterate(</div>
<div class="line">      IteratesVector&amp; warm_start_iterate </div>
<div class="line">   )</div>
<div class="line">   {</div>
<div class="line">      (void) warm_start_iterate;</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">   }</div>
</div><!-- fragment --><p>Method to provide an Ipopt warm start iterate which is already in the form Ipopt requires it internally for warm starts. This method is only for expert users. The default implementation does not provide a warm start iterate and returns false. </p>
</blockquote>
<h2><a class="anchor" id="INTERFACE_C"></a>
The C Interface</h2>
<p>The C interface for Ipopt is declared in the header file <a class="el" href="IpStdCInterface_8h.html">IpStdCInterface.h</a>, which is found in <code>$PREFIX/include/coin-or</code>; while reading this section, it will be helpful to have a look at this file.</p>
<p>In order to solve an optimization problem with the C interface, one has to create an <a class="el" href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a> with the function <a class="el" href="IpStdCInterface_8h.html#ad1c7c5bba4e9ca11142b12c1d434764e">CreateIpoptProblem</a>, which later has to be passed to the <a class="el" href="IpStdCInterface_8h.html#a5a68928c505f008c1245088bca5b7b16">IpoptSolve</a> function. <a class="el" href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a> is a pointer to a C structure; you should not access this structure directly, but only through the functions provided in the C interface.</p>
<p>The <a class="el" href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a> created by <a class="el" href="IpStdCInterface_8h.html#ad1c7c5bba4e9ca11142b12c1d434764e">CreateIpoptProblem</a> contains the problem dimensions, the variable and constraint bounds, and the function pointers for callbacks that will be used to evaluate the NLP problem functions and their derivatives (see also the discussion of the C++ methods <a class="el" href="classIpopt_1_1TNLP.html#a5da5791365764706aeda02b78f7719b6" title="Method to request the initial information about the problem.">Ipopt::TNLP::get_nlp_info</a> and <a class="el" href="classIpopt_1_1TNLP.html#aafb65734cce3659c6fb496e136636e9e" title="Method to request bounds on the variables and constraints.">Ipopt::TNLP::get_bounds_info</a> for information about the arguments of <a class="el" href="IpStdCInterface_8h.html#ad1c7c5bba4e9ca11142b12c1d434764e">CreateIpoptProblem</a>).</p>
<p>The prototypes for the callback functions, <a class="el" href="IpStdCInterface_8h.html#aab30234055c386ab38a7f50fffea65ed">Eval_F_CB</a>, <a class="el" href="IpStdCInterface_8h.html#ae26561e1d9045d17521cb5f1e9992abb">Eval_Grad_F_CB</a>, etc., are defined in the header file <a class="el" href="IpStdCInterface_8h.html">IpStdCInterface.h</a>. Their arguments correspond one-to-one to the arguments for the corresponding C++ methods; for example, for the meaning of <code>n</code>, <code>x</code>, <code>new_x</code>, <code>obj_value</code> in the declaration of <a class="el" href="IpStdCInterface_8h.html#aab30234055c386ab38a7f50fffea65ed">Eval_F_CB</a> see the discussion of <a class="el" href="classIpopt_1_1TNLP.html#a709c03900227bc573b046ce0705e6c84" title="Method to request the value of the objective function.">Ipopt::TNLP::eval_f</a>. The callback functions should return <code>TRUE</code>, unless there was a problem doing the requested function/derivative evaluation at the given point <code>x</code> (then it should return <code>FALSE</code>).</p>
<p>Note the additional argument of type <a class="el" href="IpStdCInterface_8h.html#a34729529d9e43f5954710164cafe4894">UserDataPtr</a> in the callback functions. This pointer argument is available for you to communicate information between the main program that calls <a class="el" href="IpStdCInterface_8h.html#a5a68928c505f008c1245088bca5b7b16">IpoptSolve</a> and any of the callback functions. This pointer is simply passed unmodified by Ipopt among those functions. For example, you can use this to pass constants that define the optimization problem and are computed before the optimization in the main C program to the callback functions.</p>
<p>After an <a class="el" href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a> has been created, you can set algorithmic options for Ipopt (see <a class="el" href="OPTIONS.html">Ipopt Options</a>) using the functions <a class="el" href="IpStdCInterface_8h.html#ab6b7c62bfbc8dea71b3a6f724c36b377">AddIpoptStrOption</a>, <a class="el" href="IpStdCInterface_8h.html#a7af9acc5df419794044bc4c6717a89ca">AddIpoptNumOption</a>, and <a class="el" href="IpStdCInterface_8h.html#a408cfbc4c2e69def583fd8c0ca85d88c">AddIpoptIntOption</a>. Finally, the Ipopt algorithm is called with <a class="el" href="IpStdCInterface_8h.html#a5a68928c505f008c1245088bca5b7b16">IpoptSolve</a>, giving Ipopt the <a class="el" href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a>, the starting point, and arrays to store the solution values (primal and dual variables), if desired. Finally, after everything is done, <a class="el" href="IpStdCInterface_8h.html#a2776b701c950d9700509f1e601d787f6">FreeIpoptProblem</a> should be called to release internal memory that is still allocated inside Ipopt.</p>
<p>In the remainder of this section we discuss how the example problem (HS071) can be solved using the C interface. A completed version of this example can be found in <code>Ipopt/examples/hs071_c</code>.</p>
<p>In order to implement the example problem on your own, create a new directory <code>MyCExample</code> and create a new file, <code>hs071_c.c</code>. Here, include the interface header file <a class="el" href="IpStdCInterface_8h.html">IpStdCInterface.h</a>, along with other necessary header files, such as <code>stdlib.h</code> and <code>assert.h</code>. Add the prototypes and implementations for the five callback functions. Have a look at the C++ implementation for <code>eval_f</code>, <code>eval_g</code>, <code>eval_grad_f</code>, <code>eval_jac_g</code>, and <code>eval_h</code> in <a class="el" href="INTERFACES.html#INTERFACE_CPP_NLP">Coding the Problem Representation</a>. The C implementations have somewhat different prototypes, but are implemented almost identically to the C++ code. See the completed example in <code>Ipopt/examples/hs071_c/hs071_c.c</code> if you are not sure how to do this.</p>
<p>We now need to implement the main function, create the <a class="el" href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a>, set options, and call <a class="el" href="IpStdCInterface_8h.html#a5a68928c505f008c1245088bca5b7b16">IpoptSolve</a>. The <a class="el" href="IpStdCInterface_8h.html#ad1c7c5bba4e9ca11142b12c1d434764e">CreateIpoptProblem</a> function requires the problem dimensions, the variable and constraint bounds, and the function pointers to the callback routines. The <a class="el" href="IpStdCInterface_8h.html#a5a68928c505f008c1245088bca5b7b16">IpoptSolve</a> function requires the <a class="el" href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a>, the starting point, and allocated arrays for the solution. The main function from the example is shown next and discussed below.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="IpTypes_8h.html#ad45d5b046bfaf56789665c747d5a8cb9">ipindex</a> n = -1;                      <span class="comment">/* number of variables */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#ad45d5b046bfaf56789665c747d5a8cb9">ipindex</a> m = -1;                      <span class="comment">/* number of constraints */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#ad45d5b046bfaf56789665c747d5a8cb9">ipindex</a> nele_jac;                    <span class="comment">/* number of nonzeros in the Jacobian of the constraints */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#ad45d5b046bfaf56789665c747d5a8cb9">ipindex</a> nele_hess;                   <span class="comment">/* number of nonzeros in the Hessian of the Lagrangian (lower or upper triangular part only) */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#ad45d5b046bfaf56789665c747d5a8cb9">ipindex</a> index_style;                 <span class="comment">/* indexing style for matrices */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>* x_L = NULL;                <span class="comment">/* lower bounds on x */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>* x_U = NULL;                <span class="comment">/* upper bounds on x */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>* g_L = NULL;                <span class="comment">/* lower bounds on g */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>* g_U = NULL;                <span class="comment">/* upper bounds on g */</span></div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a> nlp = NULL;             <span class="comment">/* IpoptProblem */</span></div>
<div class="line">   <span class="keyword">enum</span> <a class="code" href="IpReturnCodes__inc_8h.html#ab542e0b1ca364a9b7525a876ffdae7d7">ApplicationReturnStatus</a> status; <span class="comment">/* Solve return code */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>* x = NULL;                  <span class="comment">/* starting point and solution vector */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>* mult_g = NULL;             <span class="comment">/* constraint multipliers at the solution */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>* mult_x_L = NULL;           <span class="comment">/* lower bound multipliers at the solution */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>* mult_x_U = NULL;           <span class="comment">/* upper bound multipliers at the solution */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a> obj;                        <span class="comment">/* objective value */</span></div>
<div class="line">   <span class="keyword">struct </span>MyUserData user_data;         <span class="comment">/* our user data for the function evaluations */</span></div>
<div class="line">   <a class="code" href="IpTypes_8h.html#ad45d5b046bfaf56789665c747d5a8cb9">ipindex</a> i;                           <span class="comment">/* generic counter */</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* set the number of variables and allocate space for the bounds */</span></div>
<div class="line">   n = 4;</div>
<div class="line">   x_L = (<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>*) malloc(<span class="keyword">sizeof</span>(<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>) * n);</div>
<div class="line">   x_U = (<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>*) malloc(<span class="keyword">sizeof</span>(<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>) * n);</div>
<div class="line">   <span class="comment">/* set the values for the variable bounds */</span></div>
<div class="line">   <span class="keywordflow">for</span>( i = 0; i &lt; n; i++ )</div>
<div class="line">   {</div>
<div class="line">      x_L[i] = 1.0;</div>
<div class="line">      x_U[i] = 5.0;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* set the number of constraints and allocate space for the bounds */</span></div>
<div class="line">   m = 2;</div>
<div class="line">   g_L = (<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>*) malloc(<span class="keyword">sizeof</span>(<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>) * m);</div>
<div class="line">   g_U = (<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>*) malloc(<span class="keyword">sizeof</span>(<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>) * m);</div>
<div class="line">   <span class="comment">/* set the values of the constraint bounds */</span></div>
<div class="line">   g_L[0] = 25;</div>
<div class="line">   g_U[0] = 2e19;</div>
<div class="line">   g_L[1] = 40;</div>
<div class="line">   g_U[1] = 40;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* set the number of nonzeros in the Jacobian and Hessian */</span></div>
<div class="line">   nele_jac = 8;</div>
<div class="line">   nele_hess = 10;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* set the indexing style to C-style (start counting of rows and column indices at 0) */</span></div>
<div class="line">   index_style = 0;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* create the IpoptProblem */</span></div>
<div class="line">   nlp = <a class="code" href="IpStdCInterface_8h.html#ad1c7c5bba4e9ca11142b12c1d434764e">CreateIpoptProblem</a>(n, x_L, x_U, m, g_L, g_U, nele_jac, nele_hess, index_style,</div>
<div class="line">                            &amp;eval_f, &amp;eval_g, &amp;eval_grad_f,</div>
<div class="line">                            &amp;eval_jac_g, &amp;eval_h);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* We can free the memory now - the values for the bounds have been</span></div>
<div class="line"><span class="comment">    * copied internally in CreateIpoptProblem</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">   free(x_L);</div>
<div class="line">   free(x_U);</div>
<div class="line">   free(g_L);</div>
<div class="line">   free(g_U);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* Set some options.  Note the following ones are only examples,</span></div>
<div class="line"><span class="comment">    * they might not be suitable for your problem.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#a7af9acc5df419794044bc4c6717a89ca">AddIpoptNumOption</a>(nlp, <span class="stringliteral">&quot;tol&quot;</span>, 3.82e-6);</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab6b7c62bfbc8dea71b3a6f724c36b377">AddIpoptStrOption</a>(nlp, <span class="stringliteral">&quot;mu_strategy&quot;</span>, <span class="stringliteral">&quot;adaptive&quot;</span>);</div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#ab6b7c62bfbc8dea71b3a6f724c36b377">AddIpoptStrOption</a>(nlp, <span class="stringliteral">&quot;output_file&quot;</span>, <span class="stringliteral">&quot;ipopt.out&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* allocate space for the initial point and set the values */</span></div>
<div class="line">   x = (<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>*) malloc(<span class="keyword">sizeof</span>(<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>) * n);</div>
<div class="line">   x[0] = 1.0;</div>
<div class="line">   x[1] = 5.0;</div>
<div class="line">   x[2] = 5.0;</div>
<div class="line">   x[3] = 1.0;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* allocate space to store the bound multipliers at the solution */</span></div>
<div class="line">   mult_g = (<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>*) malloc(<span class="keyword">sizeof</span>(<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>) * m);</div>
<div class="line">   mult_x_L = (<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>*) malloc(<span class="keyword">sizeof</span>(<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>) * n);</div>
<div class="line">   mult_x_U = (<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>*) malloc(<span class="keyword">sizeof</span>(<a class="code" href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a>) * n);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* Initialize the user data */</span></div>
<div class="line">   user_data.g_offset[0] = 0.;</div>
<div class="line">   user_data.g_offset[1] = 0.;</div>
<div class="line">   user_data.nlp = nlp;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* Set the callback method for intermediate user-control.</span></div>
<div class="line"><span class="comment">    * This is not required, just gives you some intermediate control in</span></div>
<div class="line"><span class="comment">    * case you need it.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">   <span class="comment">/* SetIntermediateCallback(nlp, intermediate_cb); */</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* solve the problem */</span></div>
<div class="line">   status = <a class="code" href="IpStdCInterface_8h.html#a5a68928c505f008c1245088bca5b7b16">IpoptSolve</a>(nlp, x, NULL, &amp;obj, mult_g, mult_x_L, mult_x_U, &amp;user_data);</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">if</span>( status == <a class="code" href="IpReturnCodes__inc_8h.html#ab542e0b1ca364a9b7525a876ffdae7d7a98f85390ead47dbab52ac6d20aef904b">Solve_Succeeded</a> )</div>
<div class="line">   {</div>
<div class="line">      printf(<span class="stringliteral">&quot;\n\nSolution of the primal variables, x\n&quot;</span>);</div>
<div class="line">      <span class="keywordflow">for</span>( i = 0; i &lt; n; i++ )</div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot;x[%d] = %e\n&quot;</span>, (<span class="keywordtype">int</span>)i, x[i]);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      printf(<span class="stringliteral">&quot;\n\nSolution of the constraint multipliers, lambda\n&quot;</span>);</div>
<div class="line">      <span class="keywordflow">for</span>( i = 0; i &lt; m; i++ )</div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot;lambda[%d] = %e\n&quot;</span>, (<span class="keywordtype">int</span>)i, mult_g[i]);</div>
<div class="line">      }</div>
<div class="line">      printf(<span class="stringliteral">&quot;\n\nSolution of the bound multipliers, z_L and z_U\n&quot;</span>);</div>
<div class="line">      <span class="keywordflow">for</span>( i = 0; i &lt; n; i++ )</div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot;z_L[%d] = %e\n&quot;</span>, (<span class="keywordtype">int</span>)i, mult_x_L[i]);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">for</span>( i = 0; i &lt; n; i++ )</div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot;z_U[%d] = %e\n&quot;</span>, (<span class="keywordtype">int</span>)i, mult_x_U[i]);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      printf(<span class="stringliteral">&quot;\n\nObjective value\nf(x*) = %e\n&quot;</span>, obj);</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">else</span></div>
<div class="line">   {</div>
<div class="line">      printf(<span class="stringliteral">&quot;\n\nERROR OCCURRED DURING IPOPT OPTIMIZATION.\n&quot;</span>);</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* Now we are going to solve this problem again, but with slightly</span></div>
<div class="line"><span class="comment">    * modified constraints.  We change the constraint offset of the</span></div>
<div class="line"><span class="comment">    * first constraint a bit, and resolve the problem using the warm</span></div>
<div class="line"><span class="comment">    * start option.</span></div>
<div class="line"><span class="comment">    */</span></div>
<div class="line">   user_data.g_offset[0] = 0.2;</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">if</span>( status == <a class="code" href="IpReturnCodes__inc_8h.html#ab542e0b1ca364a9b7525a876ffdae7d7a98f85390ead47dbab52ac6d20aef904b">Solve_Succeeded</a> )</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">/* Now resolve with a warmstart. */</span></div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#ab6b7c62bfbc8dea71b3a6f724c36b377">AddIpoptStrOption</a>(nlp, <span class="stringliteral">&quot;warm_start_init_point&quot;</span>, <span class="stringliteral">&quot;yes&quot;</span>);</div>
<div class="line">      <span class="comment">/* The following option reduce the automatic modification of the</span></div>
<div class="line"><span class="comment">       * starting point done my Ipopt.</span></div>
<div class="line"><span class="comment">       */</span></div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#a7af9acc5df419794044bc4c6717a89ca">AddIpoptNumOption</a>(nlp, <span class="stringliteral">&quot;bound_push&quot;</span>, 1e-5);</div>
<div class="line">      <a class="code" href="IpStdCInterface_8h.html#a7af9acc5df419794044bc4c6717a89ca">AddIpoptNumOption</a>(nlp, <span class="stringliteral">&quot;bound_frac&quot;</span>, 1e-5);</div>
<div class="line">      status = <a class="code" href="IpStdCInterface_8h.html#a5a68928c505f008c1245088bca5b7b16">IpoptSolve</a>(nlp, x, NULL, &amp;obj, mult_g, mult_x_L, mult_x_U, &amp;user_data);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span>( status == <a class="code" href="IpReturnCodes__inc_8h.html#ab542e0b1ca364a9b7525a876ffdae7d7a98f85390ead47dbab52ac6d20aef904b">Solve_Succeeded</a> )</div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot;\n\nSolution of the primal variables, x\n&quot;</span>);</div>
<div class="line">         <span class="keywordflow">for</span>( i = 0; i &lt; n; i++ )</div>
<div class="line">         {</div>
<div class="line">            printf(<span class="stringliteral">&quot;x[%d] = %e\n&quot;</span>, (<span class="keywordtype">int</span>)i, x[i]);</div>
<div class="line">         }</div>
<div class="line"> </div>
<div class="line">         printf(<span class="stringliteral">&quot;\n\nSolution of the constraint multipliers, lambda\n&quot;</span>);</div>
<div class="line">         <span class="keywordflow">for</span>( i = 0; i &lt; m; i++ )</div>
<div class="line">         {</div>
<div class="line">            printf(<span class="stringliteral">&quot;lambda[%d] = %e\n&quot;</span>, (<span class="keywordtype">int</span>)i, mult_g[i]);</div>
<div class="line">         }</div>
<div class="line">         printf(<span class="stringliteral">&quot;\n\nSolution of the bound multipliers, z_L and z_U\n&quot;</span>);</div>
<div class="line">         <span class="keywordflow">for</span>( i = 0; i &lt; n; i++ )</div>
<div class="line">         {</div>
<div class="line">            printf(<span class="stringliteral">&quot;z_L[%d] = %e\n&quot;</span>, (<span class="keywordtype">int</span>)i, mult_x_L[i]);</div>
<div class="line">         }</div>
<div class="line">         <span class="keywordflow">for</span>( i = 0; i &lt; n; i++ )</div>
<div class="line">         {</div>
<div class="line">            printf(<span class="stringliteral">&quot;z_U[%d] = %e\n&quot;</span>, (<span class="keywordtype">int</span>)i, mult_x_U[i]);</div>
<div class="line">         }</div>
<div class="line"> </div>
<div class="line">         printf(<span class="stringliteral">&quot;\n\nObjective value\nf(x*) = %e\n&quot;</span>, obj);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">         printf(<span class="stringliteral">&quot;\n\nERROR OCCURRED DURING IPOPT OPTIMIZATION WITH WARM START.\n&quot;</span>);</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="comment">/* free allocated memory */</span></div>
<div class="line">   <a class="code" href="IpStdCInterface_8h.html#a2776b701c950d9700509f1e601d787f6">FreeIpoptProblem</a>(nlp);</div>
<div class="line">   free(x);</div>
<div class="line">   free(mult_g);</div>
<div class="line">   free(mult_x_L);</div>
<div class="line">   free(mult_x_U);</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> (status == <a class="code" href="IpReturnCodes__inc_8h.html#ab542e0b1ca364a9b7525a876ffdae7d7a98f85390ead47dbab52ac6d20aef904b">Solve_Succeeded</a>) ? EXIT_SUCCESS : EXIT_FAILURE;</div>
<div class="line">}</div>
</div><!-- fragment --><p> Here, we declare all the necessary variables and set the dimensions of the problem. The problem has 4 variables, so we set n and allocate space for the variable bounds (don't forget to call free for each of your malloc calls before the end of the program). We then set the values for the variable bounds.</p>
<p>The problem has 2 constraints, so we set m and allocate space for the constraint bounds. The first constraint has a lower bound of 25 and no upper bound. Here we set the upper bound to <code>2e19</code>. Ipopt interprets any number greater than or equal to the value of option <a class="el" href="OPTIONS.html#OPT_nlp_upper_bound_inf">nlp_upper_bound_inf</a> as infinity. The default value of <a class="el" href="OPTIONS.html#OPT_nlp_lower_bound_inf">nlp_lower_bound_inf</a> and <a class="el" href="OPTIONS.html#OPT_nlp_upper_bound_inf">nlp_upper_bound_inf</a> is <code>-1e19</code> and <code>1e19</code>, respectively, and can be changed through Ipopt options. The second constraint is an equality with right hand side 40, so we set both the upper and the lower bound to 40.</p>
<p>Next, we set the number of elements in the Jacobian and Hessian. The Jacobian has 8 nonzero entries. For the Hessian we only specify the number of nonzeros in the lower-triangular part, which is 10. See <a class="el" href="IMPL.html#TRIPLET">Triplet Format for Sparse Matrices</a> for a description of the sparse matrix format. Finally, we set the style for the row and column indices of the matrices to 0 to indicate C-Style, that is, start indexing at 0.</p>
<p>We next create an instance of the <a class="el" href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a> by calling <a class="el" href="IpStdCInterface_8h.html#ad1c7c5bba4e9ca11142b12c1d434764e">CreateIpoptProblem</a>, giving it the problem dimensions and the variable and constraint bounds. We also include the references to each of our callback functions. Ipopt uses these function pointers to ask for evaluation of the NLP when required.</p>
<p>After freeing the bound arrays that are no longer required, the next three lines illustrate how to change the value of options through the interface. Ipopt options can also be changed by creating an <code>ipopt.opt</code> file (see <a class="el" href="OPTIONS.html">Ipopt Options</a>). We next allocate space for the initial point and set the values as given in the problem definition.</p>
<p>The call to <a class="el" href="IpStdCInterface_8h.html#a5a68928c505f008c1245088bca5b7b16">IpoptSolve</a> can provide information about the solution, but most of this is optional. Here, we want values for the constraint and variable bound multipliers at the solution and thus allocate space for these.</p>
<p>Further, we initialize the <code>user_data</code> that will be accessed in the function evaluation callbacks.</p>
<p>We can now make the call to <a class="el" href="IpStdCInterface_8h.html#a5a68928c505f008c1245088bca5b7b16">IpoptSolve</a> and find the solution of the problem. We pass in the <a class="el" href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a>, the starting point <code>x</code> (Ipopt will use this array to return the solution or final point as well). The next 5 arguments are pointers so Ipopt can fill in values at the solution. If these pointers are set to <code>NULL</code>, Ipopt will ignore that entry. For example, here we do not want the constraint function values at the solution, so we set this entry to <code>NULL</code>. We do want the value of the objective, and the multipliers for the constraints and variable bounds. The last argument is a pointer to our example-specific "user data". Any pointer that is passed in here will be passed on to the callback functions.</p>
<p>The return code is an <a class="el" href="IpReturnCodes__inc_8h.html#ab542e0b1ca364a9b7525a876ffdae7d7">ApplicationReturnStatus</a> enumeration, see the header file ReturnCodes_inc.h which is installed along <a class="el" href="IpStdCInterface_8h.html">IpStdCInterface.h</a> in the Ipopt include directory. After the optimizer terminates, we check the status and print the solution if successful.</p>
<p>If the solve succeeded, we resolve a slightly modified version of the problem. We use both the primal solution point and the dual multipliers to warm-start Ipopt for this second solve. Additionally, to improve the warmstart, we reduce the amount by which Ipopt pushes the starting point into the interior of the variable bounds by setting the options <code>bound_push</code> and <code>bound_frac</code>. If the solve was successful, we print the solution again.</p>
<p>Finally, we free the <a class="el" href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a> and the remaining memory and return from <code>main</code>.</p>
<h2><a class="anchor" id="INTERFACE_FORTRAN"></a>
The Fortran Interface</h2>
<p>The Fortran interface is essentially a wrapper of the <a class="el" href="INTERFACES.html#INTERFACE_C">C Interface</a>. The way to hook up Ipopt in a Fortran program is very similar to how it is done for the C interface, and the functions of the Fortran interface correspond one-to-one to the those of the C and C++ interface, including their arguments. You can find an implementation of the example problem (HS071) in <code>$IPOPTDIR/Ipopt/examples/hs071_f</code>.</p>
<p>The only special things to consider are:</p>
<ul>
<li>The return value of the function <code>IPCREATE</code> is of type <code>INTEGER</code> that must be large enough to capture a pointer on the particular machine. This means, that you have to declare the "handle" for the <code>IpoptProblem</code> as <code>INTEGER*8</code> if your program is compiled in 64-bit mode. All other <code>INTEGER</code>-type variables must be of the regular type.</li>
<li>For the call of <code>IPSOLVE</code> (which is the function that is to be called to run Ipopt), all arrays, including those for the dual variables, must be given (in contrast to the C interface). The return value <code>IERR</code> of this function indicates the outcome of the optimization (see the include file <code>IpReturnCodes.inc</code> in the Ipopt include directory).</li>
<li>The return value <code>IERR</code> of the remaining functions has to be set to zero, unless there was a problem during execution of the function call.</li>
<li><p class="startli">The callback functions (<code>EV_*</code> in the example) include the arguments <code>IDAT</code> and <code>DAT</code>, which are <code>INTEGER</code> and <code>DOUBLE PRECISION</code> arrays that are passed unmodified between the main program calling <code>IPSOLVE</code> and the evaluation subroutines <code>EV_*</code> (similarly to <code>UserDataPtr</code> arguments in the C interface). These arrays can be used to pass "private" data between the main program and the user-provided Fortran subroutines.</p>
<p class="startli">The last argument of the <code>EV_*</code> subroutines, <code>IERR</code>, is to be set to 0 by the user on return, unless there was a problem during the evaluation of the optimization problem function/derivative for the given point <code>X</code> (then it should return a non-zero value).</p>
</li>
</ul>
<h2><a class="anchor" id="INTERFACE_JAVA"></a>
The Java Interface JIpopt</h2>
<p>This section is based on documentation by Rafael de Pelegrini Soares (VRTech Industrial Technologies).</p>
<p>The Java Interface was written and contributed by Rafael de Pelegrini Soares and later updated by Tong Kewei (Beihang University). It offers an abstract base class <a class="el" href="classorg_1_1coinor_1_1Ipopt.html">Ipopt</a> with basic methods to specify an NLP, set a number of Ipopt options, to request Ipopt to solve the NLP, and to retrieve a found solution, if any. A HTML documentation of all available interface methods of the <a class="el" href="classorg_1_1coinor_1_1Ipopt.html">Ipopt</a> class can also be generated via javadoc by executing <code>make javadoc</code> in the Ipopt build directory (<code>$IPOPTDIR</code>).</p>
<p>If the Ipopt build includes the Java interface, then a JAR file <code>org.coinor.ipopt.jar</code> containing class <a class="el" href="classorg_1_1coinor_1_1Ipopt.html" title="A Java Native Interface for the Ipopt optimization solver.">org.coinor.Ipopt</a> will have been installed in <code>$PREFIX/share/java</code>. To use the Java interface, make sure that this jar file is part of your Java classpath. A sample makefile that compiles and runs example HS071 can be found in <code>$IPOPTDIR/examples/hs071_java</code>.</p>
<p>In the following, we discuss necessary steps to implement example (HS071) with <code>JIpopt</code>. We create a new Java source file HS071.java and define a class <code>HS071</code> that extends the class <a class="el" href="classorg_1_1coinor_1_1Ipopt.html">Ipopt</a>. In the class constructor, we call the <a class="el" href="classorg_1_1coinor_1_1Ipopt.html#a974f513fe0380fa5feb582855657ea49">org.coinor.Ipopt.create()</a> method of <code>JIpopt</code>, which works analogously to <a class="el" href="classIpopt_1_1TNLP.html#a5da5791365764706aeda02b78f7719b6">Ipopt::TNLP::get_nlp_info()</a> of the C++ interface. It initializes an <a class="el" href="classIpopt_1_1IpoptApplication.html">Ipopt::IpoptApplication</a> object and informs <code>JIpopt</code> about the problem size (number of variables, constraints, nonzeros in Jacobian and Hessian).</p>
<div class="fragment"><div class="line">   <span class="keyword">public</span> HS071()</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">/* Number of nonzeros in the Jacobian of the constraints */</span></div>
<div class="line">      nele_jac = 8;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">/* Number of nonzeros in the Hessian of the Lagrangian (lower or</span></div>
<div class="line"><span class="comment">       * upper triangual part only)</span></div>
<div class="line"><span class="comment">       */</span></div>
<div class="line">      nele_hess = 10;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">/* Number of variables */</span></div>
<div class="line">      n = 4;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">/* Number of constraints */</span></div>
<div class="line">      m = 2;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">/* Index style for the irow/jcol elements */</span></div>
<div class="line">      <span class="keywordtype">int</span> index_style = <a class="code" href="namespaceIpopt.html">Ipopt</a>.C_STYLE;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">/* Whether to print iterate in intermediate_callback */</span></div>
<div class="line">      printiterate = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">/* create the IpoptProblem */</span></div>
<div class="line">      create(n, m, nele_jac, nele_hess, index_style);</div>
<div class="line">   }</div>
</div><!-- fragment --><p> Next, we add callback functions that are called by <code>JIpopt</code> to obtain variable bounds, constraint sides, and a starting point:</p>
<div class="fragment"><div class="line">   <span class="keyword">protected</span> <span class="keywordtype">boolean</span> get_bounds_info(</div>
<div class="line">      <span class="keywordtype">int</span>      n,</div>
<div class="line">      <span class="keywordtype">double</span>[] x_L,</div>
<div class="line">      <span class="keywordtype">double</span>[] x_U,</div>
<div class="line">      <span class="keywordtype">int</span>      m,</div>
<div class="line">      <span class="keywordtype">double</span>[] g_L,</div>
<div class="line">      <span class="keywordtype">double</span>[] g_U)</div>
<div class="line">   {</div>
<div class="line">      assert n == this.n;</div>
<div class="line">      assert m == this.m;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">/* set the values of the variable bounds */</span></div>
<div class="line">      <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; n; ++i )</div>
<div class="line">      {</div>
<div class="line">         x_L[i] = 1.0;</div>
<div class="line">         x_U[i] = 5.0;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="comment">/* set the values of the constraint bounds */</span></div>
<div class="line">      g_L[0] = 25.0;</div>
<div class="line">      g_U[0] = 2e19;</div>
<div class="line">      g_L[1] = 40.0;</div>
<div class="line">      g_U[1] = 40.0;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">   }</div>
</div><!-- fragment --> <div class="fragment"><div class="line">   <span class="keyword">protected</span> <span class="keywordtype">boolean</span> get_starting_point(</div>
<div class="line">      <span class="keywordtype">int</span>      n,</div>
<div class="line">      <span class="keywordtype">boolean</span>  init_x,</div>
<div class="line">      <span class="keywordtype">double</span>[] x,</div>
<div class="line">      <span class="keywordtype">boolean</span>  init_z,</div>
<div class="line">      <span class="keywordtype">double</span>[] z_L,</div>
<div class="line">      <span class="keywordtype">double</span>[] z_U,</div>
<div class="line">      <span class="keywordtype">int</span>      m,</div>
<div class="line">      <span class="keywordtype">boolean</span>  init_lambda,</div>
<div class="line">      <span class="keywordtype">double</span>[] lambda)</div>
<div class="line">   {</div>
<div class="line">      assert init_z == <span class="keyword">false</span>;</div>
<div class="line">      assert init_lambda = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span>( init_x )</div>
<div class="line">      {</div>
<div class="line">         x[0] = 1.0;</div>
<div class="line">         x[1] = 5.0;</div>
<div class="line">         x[2] = 5.0;</div>
<div class="line">         x[3] = 1.0;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">   }</div>
</div><!-- fragment --><p> In the following, we implement the evaluation methods in a way that is very similar to the C++ interface:</p>
<div class="fragment"><div class="line">   <span class="keyword">protected</span> <span class="keywordtype">boolean</span> eval_f(</div>
<div class="line">      <span class="keywordtype">int</span>      n,</div>
<div class="line">      <span class="keywordtype">double</span>[] x,</div>
<div class="line">      <span class="keywordtype">boolean</span>  new_x,</div>
<div class="line">      <span class="keywordtype">double</span>[] obj_value)</div>
<div class="line">   {</div>
<div class="line">      assert n == this.n;</div>
<div class="line"> </div>
<div class="line">      obj_value[0] = x[0] * x[3] * (x[0] + x[1] + x[2]) + x[2];</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">protected</span> <span class="keywordtype">boolean</span> eval_grad_f(</div>
<div class="line">      <span class="keywordtype">int</span>      n,</div>
<div class="line">      <span class="keywordtype">double</span>[] x,</div>
<div class="line">      <span class="keywordtype">boolean</span>  new_x,</div>
<div class="line">      <span class="keywordtype">double</span>[] grad_f)</div>
<div class="line">   {</div>
<div class="line">      assert n == this.n;</div>
<div class="line"> </div>
<div class="line">      grad_f[0] = x[0] * x[3] + x[3] * (x[0] + x[1] + x[2]);</div>
<div class="line">      grad_f[1] = x[0] * x[3];</div>
<div class="line">      grad_f[2] = x[0] * x[3] + 1;</div>
<div class="line">      grad_f[3] = x[0] * (x[0] + x[1] + x[2]);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">protected</span> <span class="keywordtype">boolean</span> eval_g(</div>
<div class="line">      <span class="keywordtype">int</span>      n,</div>
<div class="line">      <span class="keywordtype">double</span>[] x,</div>
<div class="line">      <span class="keywordtype">boolean</span>  new_x,</div>
<div class="line">      <span class="keywordtype">int</span>      m,</div>
<div class="line">      <span class="keywordtype">double</span>[] g)</div>
<div class="line">   {</div>
<div class="line">      assert n == this.n;</div>
<div class="line">      assert m == this.m;</div>
<div class="line"> </div>
<div class="line">      g[0] = x[0] * x[1] * x[2] * x[3];</div>
<div class="line">      g[1] = x[0] * x[0] + x[1] * x[1] + x[2] * x[2] + x[3] * x[3];</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">protected</span> <span class="keywordtype">boolean</span> eval_jac_g(</div>
<div class="line">      <span class="keywordtype">int</span>      n,</div>
<div class="line">      <span class="keywordtype">double</span>[] x,</div>
<div class="line">      <span class="keywordtype">boolean</span>  new_x,</div>
<div class="line">      <span class="keywordtype">int</span>      m,</div>
<div class="line">      <span class="keywordtype">int</span>      nele_jac,</div>
<div class="line">      <span class="keywordtype">int</span>[]    iRow,</div>
<div class="line">      <span class="keywordtype">int</span>[]    jCol,</div>
<div class="line">      <span class="keywordtype">double</span>[] values)</div>
<div class="line">   {</div>
<div class="line">      assert n == this.n;</div>
<div class="line">      assert m == this.m;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span>( values == <span class="keyword">null</span> )</div>
<div class="line">      {</div>
<div class="line">         <span class="comment">/* return the structure of the jacobian */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* this particular jacobian is dense */</span></div>
<div class="line">         iRow[0] = 0;</div>
<div class="line">         jCol[0] = 0;</div>
<div class="line">         iRow[1] = 0;</div>
<div class="line">         jCol[1] = 1;</div>
<div class="line">         iRow[2] = 0;</div>
<div class="line">         jCol[2] = 2;</div>
<div class="line">         iRow[3] = 0;</div>
<div class="line">         jCol[3] = 3;</div>
<div class="line">         iRow[4] = 1;</div>
<div class="line">         jCol[4] = 0;</div>
<div class="line">         iRow[5] = 1;</div>
<div class="line">         jCol[5] = 1;</div>
<div class="line">         iRow[6] = 1;</div>
<div class="line">         jCol[6] = 2;</div>
<div class="line">         iRow[7] = 1;</div>
<div class="line">         jCol[7] = 3;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">         <span class="comment">/* return the values of the jacobian of the constraints */</span></div>
<div class="line"> </div>
<div class="line">         values[0] = x[1] * x[2] * x[3]; <span class="comment">/* 0,0 */</span></div>
<div class="line">         values[1] = x[0] * x[2] * x[3]; <span class="comment">/* 0,1 */</span></div>
<div class="line">         values[2] = x[0] * x[1] * x[3]; <span class="comment">/* 0,2 */</span></div>
<div class="line">         values[3] = x[0] * x[1] * x[2]; <span class="comment">/* 0,3 */</span></div>
<div class="line"> </div>
<div class="line">         values[4] = 2.0 * x[0];           <span class="comment">/* 1,0 */</span></div>
<div class="line">         values[5] = 2.0 * x[1];           <span class="comment">/* 1,1 */</span></div>
<div class="line">         values[6] = 2.0 * x[2];           <span class="comment">/* 1,2 */</span></div>
<div class="line">         values[7] = 2.0 * x[3];           <span class="comment">/* 1,3 */</span></div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keyword">protected</span> <span class="keywordtype">boolean</span> eval_h(</div>
<div class="line">      <span class="keywordtype">int</span>      n,</div>
<div class="line">      <span class="keywordtype">double</span>[] x,</div>
<div class="line">      <span class="keywordtype">boolean</span>  new_x,</div>
<div class="line">      <span class="keywordtype">double</span>   obj_factor,</div>
<div class="line">      <span class="keywordtype">int</span>      m,</div>
<div class="line">      <span class="keywordtype">double</span>[] lambda,</div>
<div class="line">      <span class="keywordtype">boolean</span>  new_lambda,</div>
<div class="line">      <span class="keywordtype">int</span>      nele_hess,</div>
<div class="line">      <span class="keywordtype">int</span>[]    iRow,</div>
<div class="line">      <span class="keywordtype">int</span>[]    jCol,</div>
<div class="line">      <span class="keywordtype">double</span>[] values)</div>
<div class="line">   {</div>
<div class="line">      assert n == this.n;</div>
<div class="line">      assert m == this.m;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">int</span> idx = 0; <span class="comment">/* nonzero element counter */</span></div>
<div class="line">      <span class="keywordtype">int</span> row = 0; <span class="comment">/* row counter for loop */</span></div>
<div class="line">      <span class="keywordtype">int</span> col = 0; <span class="comment">/* col counter for loop */</span></div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">if</span> (values == <span class="keyword">null</span>)</div>
<div class="line">      {</div>
<div class="line">         <span class="comment">/* return the structure</span></div>
<div class="line"><span class="comment">          * This is a symmetric matrix, fill the lower left triangle only.</span></div>
<div class="line"><span class="comment">          */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* the hessian for this problem is actually dense */</span></div>
<div class="line">         idx = 0;</div>
<div class="line">         <span class="keywordflow">for</span>( row = 0; row &lt; n; ++row )</div>
<div class="line">            <span class="keywordflow">for</span> (col = 0; col &lt;= row; ++col)</div>
<div class="line">            {</div>
<div class="line">               iRow[idx] = row;</div>
<div class="line">               jCol[idx] = col;</div>
<div class="line">               ++idx;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">         assert idx == nele_hess;</div>
<div class="line">         assert nele_hess == this.nele_hess;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">         <span class="comment">/* return the values.</span></div>
<div class="line"><span class="comment">          * This is a symmetric matrix, fill the lower left triangle only.</span></div>
<div class="line"><span class="comment">          */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* fill the objective portion */</span></div>
<div class="line">         values[0] = obj_factor * (2.0 * x[3]);               <span class="comment">/* 0,0 */</span></div>
<div class="line">         values[1] = obj_factor * (x[3]);                     <span class="comment">/* 1,0 */</span></div>
<div class="line">         values[2] = 0.0;                                     <span class="comment">/* 1,1 */</span></div>
<div class="line">         values[3] = obj_factor * (x[3]);                     <span class="comment">/* 2,0 */</span></div>
<div class="line">         values[4] = 0.0;                                     <span class="comment">/* 2,1 */</span></div>
<div class="line">         values[5] = 0.0;                                     <span class="comment">/* 2,2 */</span></div>
<div class="line">         values[6] = obj_factor * (2.0 * x[0] + x[1] + x[2]); <span class="comment">/* 3,0 */</span></div>
<div class="line">         values[7] = obj_factor * (x[0]);                     <span class="comment">/* 3,1 */</span></div>
<div class="line">         values[8] = obj_factor * (x[0]);                     <span class="comment">/* 3,2 */</span></div>
<div class="line">         values[9] = 0.0;                                     <span class="comment">/* 3,3 */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* add the portion for the first constraint */</span></div>
<div class="line">         values[1] += lambda[0] * (x[2] * x[3]);            <span class="comment">/* 1,0 */</span></div>
<div class="line">         values[3] += lambda[0] * (x[1] * x[3]);            <span class="comment">/* 2,0 */</span></div>
<div class="line">         values[4] += lambda[0] * (x[0] * x[3]);            <span class="comment">/* 2,1 */</span></div>
<div class="line">         values[6] += lambda[0] * (x[1] * x[2]);            <span class="comment">/* 3,0 */</span></div>
<div class="line">         values[7] += lambda[0] * (x[0] * x[2]);            <span class="comment">/* 3,1 */</span></div>
<div class="line">         values[8] += lambda[0] * (x[0] * x[1]);            <span class="comment">/* 3,2 */</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">/* add the portion for the second constraint */</span></div>
<div class="line">         values[0] += lambda[1] * 2.0;                      <span class="comment">/* 0,0 */</span></div>
<div class="line">         values[2] += lambda[1] * 2.0;                      <span class="comment">/* 1,1 */</span></div>
<div class="line">         values[5] += lambda[1] * 2.0;                      <span class="comment">/* 2,2 */</span></div>
<div class="line">         values[9] += lambda[1] * 2.0;                      <span class="comment">/* 3,3 */</span></div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">   }</div>
</div><!-- fragment --><p> For this example, we override the callback that is called by Ipopt in every iteration and can be used to indicate to Ipopt whether to stop prematurely. We use this callback to print the current iterate and its violations of primal and dual feasibility (obtained via <a class="el" href="classorg_1_1coinor_1_1Ipopt.html#ac99c6c1aa98865aa73a2b1079a671024">get_curr_iterate()</a> and <a class="el" href="classorg_1_1coinor_1_1Ipopt.html#a6596d5beb266e5e60d57a9d5e52c8efa">get_curr_violations()</a>, resp.):</p>
<div class="fragment"><div class="line">   <span class="keyword">public</span> <span class="keywordtype">boolean</span> intermediate_callback(</div>
<div class="line">      <span class="keywordtype">int</span>      algorithmmode,</div>
<div class="line">      <span class="keywordtype">int</span>      iter,</div>
<div class="line">      <span class="keywordtype">double</span>   obj_value,</div>
<div class="line">      <span class="keywordtype">double</span>   inf_pr,</div>
<div class="line">      <span class="keywordtype">double</span>   inf_du,</div>
<div class="line">      <span class="keywordtype">double</span>   mu,</div>
<div class="line">      <span class="keywordtype">double</span>   d_norm,</div>
<div class="line">      <span class="keywordtype">double</span>   regularization_size,</div>
<div class="line">      <span class="keywordtype">double</span>   alpha_du,</div>
<div class="line">      <span class="keywordtype">double</span>   alpha_pr,</div>
<div class="line">      <span class="keywordtype">int</span>      ls_trials,</div>
<div class="line">      <span class="keywordtype">long</span>     ip_data,</div>
<div class="line">      <span class="keywordtype">long</span>     ip_cq)</div>
<div class="line">   {</div>
<div class="line">      <span class="keywordflow">if</span>( !printiterate )</div>
<div class="line">      {</div>
<div class="line">         <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> x[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[n];</div>
<div class="line">      <span class="keywordtype">double</span> z_L[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[n];</div>
<div class="line">      <span class="keywordtype">double</span> z_U[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[n];</div>
<div class="line">      <span class="keywordtype">double</span> x_L_viol[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[n];</div>
<div class="line">      <span class="keywordtype">double</span> x_U_viol[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[n];</div>
<div class="line">      <span class="keywordtype">double</span> compl_x_L[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[n];</div>
<div class="line">      <span class="keywordtype">double</span> compl_x_U[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[n];</div>
<div class="line">      <span class="keywordtype">double</span> grad_lag_x[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[n];</div>
<div class="line">      <span class="keywordtype">double</span> g[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[m];</div>
<div class="line">      <span class="keywordtype">double</span> lambda[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[m];</div>
<div class="line">      <span class="keywordtype">double</span> constr_viol[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[m];</div>
<div class="line">      <span class="keywordtype">double</span> compl_g[] = <span class="keyword">new</span> <span class="keywordtype">double</span>[m];</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">boolean</span> have_iter = get_curr_iterate(ip_data, ip_cq, <span class="keyword">false</span>, n, x, z_L, z_U, m, g, lambda);</div>
<div class="line">      <span class="keywordtype">boolean</span> have_viol = get_curr_violations(ip_data, ip_cq, <span class="keyword">false</span>, n, x_L_viol, x_U_viol, compl_x_L, compl_x_U, grad_lag_x, m, constr_viol, compl_g);</div>
<div class="line"> </div>
<div class="line">      System.out.println(<span class="stringliteral">&quot;Current iterate at iteration &quot;</span> + iter + <span class="stringliteral">&quot;:&quot;</span>);</div>
<div class="line">      System.out.println(<span class="stringliteral">&quot;  x z_L z_U bound_viol compl_x_L compl_x_U grad_lag_x&quot;</span>);</div>
<div class="line">      <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; n; ++i )</div>
<div class="line">      {</div>
<div class="line">         <span class="keywordflow">if</span>( have_iter )</div>
<div class="line">         {</div>
<div class="line">            System.out.print(<span class="stringliteral">&quot;  &quot;</span> + x[i] + <span class="stringliteral">&quot; &quot;</span> + z_L[i] + <span class="stringliteral">&quot; &quot;</span> + z_U[i]);</div>
<div class="line">         }</div>
<div class="line">         <span class="keywordflow">else</span></div>
<div class="line">         {</div>
<div class="line">            System.out.print(<span class="stringliteral">&quot;  n/a n/a n/a&quot;</span>);</div>
<div class="line">         }</div>
<div class="line">         <span class="keywordflow">if</span>( have_viol )</div>
<div class="line">         {</div>
<div class="line">            System.out.println(<span class="stringliteral">&quot; &quot;</span> + Math.max(x_L_viol[i], x_U_viol[i]) + <span class="stringliteral">&quot; &quot;</span> + compl_x_L[i] + <span class="stringliteral">&quot; &quot;</span> + compl_x_U[i] + <span class="stringliteral">&quot; &quot;</span> + grad_lag_x[i]);</div>
<div class="line">         }</div>
<div class="line">         <span class="keywordflow">else</span></div>
<div class="line">         {</div>
<div class="line">            System.out.println(<span class="stringliteral">&quot;  n/a/ n/a n/a n/a&quot;</span>);</div>
<div class="line">         }</div>
<div class="line">      }</div>
<div class="line">      System.out.println(<span class="stringliteral">&quot;  g(x) lambda constr_viol compl_g&quot;</span>);</div>
<div class="line">      <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; m; ++i )</div>
<div class="line">      {</div>
<div class="line">         <span class="keywordflow">if</span>( have_iter )</div>
<div class="line">         {</div>
<div class="line">            System.out.print(<span class="stringliteral">&quot;  &quot;</span> + g[i] + <span class="stringliteral">&quot; &quot;</span> + lambda[i]);</div>
<div class="line">         }</div>
<div class="line">         <span class="keywordflow">else</span></div>
<div class="line">         {</div>
<div class="line">            System.out.print(<span class="stringliteral">&quot;  n/a n/a&quot;</span>);</div>
<div class="line">         }</div>
<div class="line">         <span class="keywordflow">if</span>( have_viol )</div>
<div class="line">         {</div>
<div class="line">            System.out.println(<span class="stringliteral">&quot; &quot;</span> + constr_viol[i] + <span class="stringliteral">&quot; &quot;</span> + compl_g[i]);</div>
<div class="line">         }</div>
<div class="line">         <span class="keywordflow">else</span></div>
<div class="line">         {</div>
<div class="line">            System.out.println(<span class="stringliteral">&quot; n/a + n/a&quot;</span>);</div>
<div class="line">         }</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">   }</div>
</div><!-- fragment --><p> Finally, we add a main routine to run this example. The main routines creates an instance of our class, calls the solve method <a class="el" href="classorg_1_1coinor_1_1Ipopt.html#ae1d61a61ade3ef02dea4441196f42b95">OptimizeNLP</a>, and prints the solution.</p>
<div class="fragment"><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keywordtype">void</span> main(String[] args)</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// Create the problem</span></div>
<div class="line">      HS071 hs071 = <span class="keyword">new</span> HS071();</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Set some options</span></div>
<div class="line">      <span class="comment">// hs071.setNumericOption(&quot;tol&quot;,1E-7);</span></div>
<div class="line">      <span class="comment">// hs071.setStringOption(&quot;nlp_scaling_method&quot;,&quot;user-scaling&quot;);</span></div>
<div class="line">      <span class="comment">// hs071.setStringOption(&quot;print_options_documentation&quot;,&quot;yes&quot;);</span></div>
<div class="line">      <span class="comment">// hs071.setStringOption(&quot;warm_start_init_point&quot;,&quot;yes&quot;);</span></div>
<div class="line">      <span class="comment">// hs071.setNumericOption(&quot;warm_start_bound_push&quot;,1e-9);</span></div>
<div class="line">      <span class="comment">// hs071.setNumericOption(&quot;warm_start_bound_frac&quot;,1e-9);</span></div>
<div class="line">      <span class="comment">// hs071.setNumericOption(&quot;warm_start_slack_bound_frac&quot;,1e-9);</span></div>
<div class="line">      <span class="comment">// hs071.setNumericOption(&quot;warm_start_slack_bound_push&quot;,1e-9);</span></div>
<div class="line">      <span class="comment">// hs071.setNumericOption(&quot;warm_start_mult_bound_push&quot;,1e-9);</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// enable printing of current iterate in intermediate_callback</span></div>
<div class="line">      <span class="comment">// hs071.printiterate = true;</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Solve the problem</span></div>
<div class="line">      <span class="keywordtype">int</span> status = hs071.OptimizeNLP();</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Print the solution</span></div>
<div class="line">      <span class="keywordflow">if</span>( status == SOLVE_SUCCEEDED )</div>
<div class="line">      {</div>
<div class="line">         System.out.println(<span class="stringliteral">&quot;\n\n*** The problem solved!&quot;</span>);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">         System.out.println(<span class="stringliteral">&quot;\n\n*** The problem was not solved successfully!&quot;</span>);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> obj = hs071.getObjectiveValue();</div>
<div class="line">      System.out.println(<span class="stringliteral">&quot;\nObjective Value = &quot;</span> + obj + <span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> x[] = hs071.getVariableValues();</div>
<div class="line">      hs071.print(x, <span class="stringliteral">&quot;Primal Variable Values:&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> constraints[] = hs071.getConstraintValues();</div>
<div class="line">      hs071.print(constraints, <span class="stringliteral">&quot;Constraint Values:&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> MLB[] = hs071.getLowerBoundMultipliers();</div>
<div class="line">      hs071.print(MLB, <span class="stringliteral">&quot;Dual Multipliers for Variable Lower Bounds:&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> MUB[] = hs071.getUpperBoundMultipliers();</div>
<div class="line">      hs071.print(MUB, <span class="stringliteral">&quot;Dual Multipliers for Variable Upper Bounds:&quot;</span>);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordtype">double</span> lam[] = hs071.getConstraintMultipliers();</div>
<div class="line">      hs071.print(lam, <span class="stringliteral">&quot;Dual Multipliers for Constraints:&quot;</span>);</div>
<div class="line">   }</div>
</div><!-- fragment --><p> The <a class="el" href="classorg_1_1coinor_1_1Ipopt.html#ae1d61a61ade3ef02dea4441196f42b95">OptimizeNLP</a> method returns the Ipopt solve status as integer, which indicates whether the problem was solved successfully. Further, the methods <a class="el" href="classorg_1_1coinor_1_1Ipopt.html#a6e22ba48fd43ad6e07bc133d0b46dca3">getObjectiveValue()</a>, <a class="el" href="classorg_1_1coinor_1_1Ipopt.html#a006f218ae1bc42c63216db173b42223f">getVariableValues()</a>, <a class="el" href="classorg_1_1coinor_1_1Ipopt.html#a1882082223e449aee081fd9c22c25644">getConstraintMultipliers()</a>, <a class="el" href="classorg_1_1coinor_1_1Ipopt.html#aa853ce288ebbb156ee49a31c6632de8f">getLowerBoundMultipliers()</a>, and <a class="el" href="classorg_1_1coinor_1_1Ipopt.html#a7f559255a7c9f289644c5b320c06e3cc">getUpperBoundMultipliers()</a> can be used to obtain the objective value, the primal solution value of the variables, and dual solution values.</p>
<h2><a class="anchor" id="INTERFACE_R"></a>
The R Interface ipoptr</h2>
<p>This section is based on documentation by Jelmer Ypma (University College London).</p>
<p>The <code>ipoptr</code> package (see also <a class="el" href="INSTALL.html#INSTALL_R">Compiling and Installing the R Interface ipoptr</a>) offers a R function <code>ipoptr</code> which takes an NLP specification, a starting point, and Ipopt options as input and returns information about an Ipopt run (status, message, ...) and a solution point.</p>
<p>In the following, we discuss necessary steps to implement example (HS071) with <code>ipoptr</code>. A more detailed documentation of <code>ipoptr</code> is available in <a href="https://github.com/coin-or/Ipopt/raw/master/contrib/RInterface/inst/doc/ipoptr.pdf">contrib/RInterface/inst/doc/ipoptr.pdf</a>.</p>
<p>First, we define the objective function and its gradient </p><div class="fragment"><div class="line">&gt; eval_f &lt;- function( x ) {</div>
<div class="line">    return( x[1]*x[4]*(x[1] + x[2] + x[3]) + x[3] )</div>
<div class="line">  }</div>
<div class="line">&gt; eval_grad_f &lt;- function( x ) {</div>
<div class="line">    return( c( x[1] * x[4] + x[4] * (x[1] + x[2] + x[3]),</div>
<div class="line">               x[1] * x[4],</div>
<div class="line">               x[1] * x[4] + 1.0,</div>
<div class="line">               x[1] * (x[1] + x[2] + x[3]) ) )</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Then we define a function that returns the value of the two constraints. We define the bounds of the constraints (in this case the <code>g_L</code> and <code>g_U</code> are 25 and 40) later. </p><div class="fragment"><div class="line">&gt; # constraint functions</div>
<div class="line">&gt; eval_g &lt;- function( x ) {</div>
<div class="line">     return( c( x[1] * x[2] * x[3] * x[4],</div>
<div class="line">                x[1]^2 + x[2]^2 + x[3]^2 + x[4]^2 ) )</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Then we define the structure of the Jacobian, which is a dense matrix in this case, and function to evaluate it </p><div class="fragment"><div class="line">&gt; eval_jac_g_structure &lt;- list( c(1,2,3,4), c(1,2,3,4) )</div>
<div class="line">&gt; eval_jac_g &lt;- function( x ) {</div>
<div class="line">     return( c ( x[2]*x[3]*x[4],</div>
<div class="line">                 x[1]*x[3]*x[4],</div>
<div class="line">                 x[1]*x[2]*x[4],</div>
<div class="line">                 x[1]*x[2]*x[3],</div>
<div class="line">                 2.0*x[1],</div>
<div class="line">                 2.0*x[2],</div>
<div class="line">                 2.0*x[3],</div>
<div class="line">                 2.0*x[4] ) )</div>
<div class="line">  }</div>
</div><!-- fragment --><p>The Hessian is also dense, but it looks slightly more complicated because we have to take into account the Hessian of the objective function and of the constraints at the same time, although you could write a function to calculate them both separately and then return the combined result in <code>eval_h</code>. </p><div class="fragment"><div class="line">&gt; # The Hessian for this problem is actually dense,</div>
<div class="line">&gt; # This is a symmetric matrix, fill the lower left triangle only.</div>
<div class="line">&gt; eval_h_structure &lt;- list( c(1), c(1,2), c(1,2,3), c(1,2,3,4) )</div>
<div class="line">&gt; eval_h &lt;- function( x, obj_factor, hessian_lambda ) {</div>
<div class="line">     values &lt;- numeric(10)</div>
<div class="line">     values[1] = obj_factor * (2*x[4]) # 1,1</div>
<div class="line"> </div>
<div class="line">     values[2] = obj_factor * (x[4])   # 2,1</div>
<div class="line">     values[3] = 0                     # 2,2</div>
<div class="line"> </div>
<div class="line">     values[4] = obj_factor * (x[4])   # 3,1</div>
<div class="line">     values[5] = 0                     # 4,2</div>
<div class="line">     values[6] = 0                     # 3,3</div>
<div class="line"> </div>
<div class="line">     values[7] = obj_factor * (2*x[1] + x[2] + x[3]) # 4,1</div>
<div class="line">     values[8] = obj_factor * (x[1])                 # 4,2</div>
<div class="line">     values[9] = obj_factor * (x[1])                 # 4,3</div>
<div class="line">     values[10] = 0                                  # 4,4</div>
<div class="line"> </div>
<div class="line">     # add the portion for the first constraint</div>
<div class="line">     values[2] = values[2] + hessian_lambda[1] * (x[3] * x[4]) # 2,1</div>
<div class="line"> </div>
<div class="line">     values[4] = values[4] + hessian_lambda[1] * (x[2] * x[4]) # 3,1</div>
<div class="line">     values[5] = values[5] + hessian_lambda[1] * (x[1] * x[4]) # 3,2</div>
<div class="line"> </div>
<div class="line">     values[7] = values[7] + hessian_lambda[1] * (x[2] * x[3]) # 4,1</div>
<div class="line">     values[8] = values[8] + hessian_lambda[1] * (x[1] * x[3]) # 4,2</div>
<div class="line">     values[9] = values[9] + hessian_lambda[1] * (x[1] * x[2]) # 4,3</div>
<div class="line"> </div>
<div class="line">     # add the portion for the second constraint</div>
<div class="line">     values[1] = values[1] + hessian_lambda[2] * 2 # 1,1</div>
<div class="line">     values[3] = values[3] + hessian_lambda[2] * 2 # 2,2</div>
<div class="line">     values[6] = values[6] + hessian_lambda[2] * 2 # 3,3</div>
<div class="line">     values[10] = values[10] + hessian_lambda[2] * 2 # 4,4</div>
<div class="line"> </div>
<div class="line">     return ( values )</div>
<div class="line">  }</div>
</div><!-- fragment --><p>After the hard part is done, we only have to define the initial values, the lower and upper bounds of the control variables, and the lower and upper bounds of the constraints. If a variable or a constraint does not have lower or upper bounds, the values <code>-Inf</code> or <code>Inf</code> can be used. If the upper and lower bounds of a constraint are equal, Ipopt recognizes this as an equality constraint and acts accordingly. </p><div class="fragment"><div class="line">&gt; # initial values</div>
<div class="line">&gt; x0 &lt;- c( 1, 5, 5, 1 )</div>
<div class="line">&gt; # lower and upper bounds of control</div>
<div class="line">&gt; lb &lt;- c( 1, 1, 1, 1 )</div>
<div class="line">&gt; ub &lt;- c( 5, 5, 5, 5 )</div>
<div class="line">&gt; # lower and upper bounds of constraints</div>
<div class="line">&gt; constraint_lb &lt;- c(  25, 40 )</div>
<div class="line">&gt; constraint_ub &lt;- c( Inf, 40 )</div>
</div><!-- fragment --><p>Finally, we can call Ipopt with the <code>ipoptr</code> function. In order to redirect the Ipopt output into a file, we use Ipopt's and options. </p><div class="fragment"><div class="line">&gt; opts &lt;- list(&quot;print_level&quot; = 0,</div>
<div class="line">               &quot;file_print_level&quot; = 12,</div>
<div class="line">               &quot;output_file&quot; = &quot;hs071_nlp.out&quot;)</div>
<div class="line">&gt; print( ipoptr( x0 = x0,</div>
<div class="line">                 eval_f = eval_f,</div>
<div class="line">                 eval_grad_f = eval_grad_f,</div>
<div class="line">                 lb = lb,</div>
<div class="line">                 ub = ub,</div>
<div class="line">                 eval_g = eval_g,</div>
<div class="line">                 eval_jac_g = eval_jac_g,</div>
<div class="line">                 constraint_lb = constraint_lb,</div>
<div class="line">                 constraint_ub = constraint_ub,</div>
<div class="line">                 eval_jac_g_structure = eval_jac_g_structure,</div>
<div class="line">                 eval_h = eval_h,</div>
<div class="line">                 eval_h_structure = eval_h_structure,</div>
<div class="line">                 opts = opts) )</div>
<div class="line"> </div>
<div class="line">Call:</div>
<div class="line"> </div>
<div class="line">ipoptr(x0 = x0, eval_f = eval_f, eval_grad_f = eval_grad_f, lb = lb,</div>
<div class="line">  ub = ub, eval_g = eval_g, eval_jac_g = eval_jac_g,</div>
<div class="line">  eval_jac_g_structure = eval_jac_g_structure, constraint_lb = constraint_lb,</div>
<div class="line">  constraint_ub = constraint_ub, eval_h = eval_h, eval_h_structure = eval_h_structure,</div>
<div class="line">  opts = opts)</div>
<div class="line"> </div>
<div class="line">Ipopt solver status: 0 ( SUCCESS: Algorithm terminated</div>
<div class="line">successfully at a locally optimal point, satisfying the</div>
<div class="line">convergence tolerances (can be specified by options). )</div>
<div class="line"> </div>
<div class="line">Number of Iterations....: 8</div>
<div class="line">Optimal value of objective function:  17.0140171451792</div>
<div class="line">Optimal value of controls: 1 4.743 3.82115 1.379408</div>
</div><!-- fragment --><p>To pass additional data to the evaluation routines, one can either supply additional arguments to the user defined functions and <code>ipoptr</code> or define an environment that holds the data and pass this environment to <code>ipoptr</code>. Both methods are shown in the file <code>tests/parameters.R</code> that comes with <code>ipoptr</code>.</p>
<p>As a very simple example, suppose we want to find the minimum of \(f(x) = a_1 x^2 + a_2 x + a_3\) for different values of the parameters \(a_1\), \(a_2\) and \(a_3\).</p>
<p>First, we define the objective function and its gradient using, assuming that there is some variable <code>params</code> that contains the values of the parameters. </p><div class="fragment"><div class="line">&gt; eval_f_ex1 &lt;- function(x, params) {</div>
<div class="line">     return( params[1]*x^2 + params[2]*x + params[3] )</div>
<div class="line">  }</div>
<div class="line">&gt; eval_grad_f_ex1 &lt;- function(x, params) {</div>
<div class="line">     return( 2*params[1]*x + params[2] )</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Note, that the first parameter should always be the control variable. All of the user-defined functions should contain the same set of additional parameters. You have to supply them as input argument to all functions, even if you're not using them in some of the functions.</p>
<p>Then we can solve the problem for a specific set of parameters, in this case \(a_1=1\), \(a_2=2\), and \(a_3=3\), from initial value \(x_0=0\), with the following command </p><div class="fragment"><div class="line">&gt; # solve using ipoptr with additional parameters</div>
<div class="line">&gt; ipoptr(x0          = 0,</div>
<div class="line">         eval_f      = eval_f_ex1,</div>
<div class="line">         eval_grad_f = eval_grad_f_ex1,</div>
<div class="line">         opts        = list(&quot;print_level&quot;=0),</div>
<div class="line">         params      = c(1,2,3) )</div>
<div class="line"> </div>
<div class="line">Call:</div>
<div class="line"> </div>
<div class="line">ipoptr(x0 = 0, eval_f = eval_f_ex1, eval_grad_f = eval_grad_f_ex1,</div>
<div class="line">    opts = list(print_level = 0), params = c(1, 2, 3))</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Ipopt solver status: 0 ( SUCCESS: Algorithm terminated</div>
<div class="line">successfully at a locally optimal point, satisfying the</div>
<div class="line">convergence tolerances (can be specified by options). )</div>
<div class="line"> </div>
<div class="line">Number of Iterations....: 1</div>
<div class="line">Optimal value of objective function:  2</div>
<div class="line">Optimal value of controls: -1</div>
</div><!-- fragment --><p>For the second method, we don't have to supply the parameters as additional arguments to the function. </p><div class="fragment"><div class="line">&gt; eval_f_ex2 &lt;- function(x) {</div>
<div class="line">     return( params[1]*x^2 + params[2]*x + params[3] )</div>
<div class="line">  }</div>
<div class="line">&gt; eval_grad_f_ex2 &lt;- function(x) {</div>
<div class="line">     return( 2*params[1]*x + params[2] )</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Instead, we define an environment that contains specific values of <code>params</code>: </p><div class="fragment"><div class="line">&gt; # define a new environment that contains params</div>
<div class="line">&gt; auxdata        &lt;- new.env()</div>
<div class="line">&gt; auxdata$params &lt;- c(1,2,3)</div>
</div><!-- fragment --><p>To solve this we supply <code>auxdata</code> as an argument to <code>ipoptr</code>, which will take care of evaluating the functions in the correct environment, so that the auxiliary data is available. </p><div class="fragment"><div class="line">&gt; # pass the environment that should be used to evaluate functions to ipoptr</div>
<div class="line">&gt; ipoptr(x0                 = 0,</div>
<div class="line">         eval_f             = eval_f_ex2,</div>
<div class="line">         eval_grad_f        = eval_grad_f_ex2,</div>
<div class="line">         ipoptr_environment = auxdata,</div>
<div class="line">         opts               = list(&quot;print_level&quot;=0) )</div>
<div class="line"> </div>
<div class="line">Call:</div>
<div class="line"> </div>
<div class="line">ipoptr(x0 = 0, eval_f = eval_f_ex2, eval_grad_f = eval_grad_f_ex2,</div>
<div class="line">    opts = list(print_level = 0), ipoptr_environment = auxdata)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">Ipopt solver status: 0 ( SUCCESS: Algorithm terminated</div>
<div class="line">successfully at a locally optimal point, satisfying the</div>
<div class="line">convergence tolerances (can be specified by options). )</div>
<div class="line"> </div>
<div class="line">Number of Iterations....: 1</div>
<div class="line">Optimal value of objective function:  2</div>
<div class="line">Optimal value of controls: -1</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespaceIpopt_html"><div class="ttname"><a href="namespaceIpopt.html">Ipopt</a></div><div class="ttdoc">This file contains a base class for all exceptions and a set of macros to help with exceptions.</div><div class="ttdef"><b>Definition:</b> <a href="IpInexactAlgBuilder_8hpp_source.html#l00013">IpInexactAlgBuilder.hpp:14</a></div></div>
<div class="ttc" id="anamespaceIpopt_html_a08458195ba30ac6f9e88a2a48c87df52"><div class="ttname"><a href="namespaceIpopt.html#a08458195ba30ac6f9e88a2a48c87df52">Ipopt::NumericMetaDataMapType</a></div><div class="ttdeci">std::map&lt; std::string, std::vector&lt; Number &gt; &gt; NumericMetaDataMapType</div><div class="ttdef"><b>Definition:</b> <a href="IpDenseVector_8hpp_source.html#l00329">IpDenseVector.hpp:329</a></div></div>
<div class="ttc" id="aIpStdCInterface_8h_html_a2776b701c950d9700509f1e601d787f6"><div class="ttname"><a href="IpStdCInterface_8h.html#a2776b701c950d9700509f1e601d787f6">FreeIpoptProblem</a></div><div class="ttdeci">IPOPTLIB_EXPORT void IPOPT_CALLCONV FreeIpoptProblem(IpoptProblem ipopt_problem)</div><div class="ttdoc">Method for freeing a previously created IpoptProblem.</div></div>
<div class="ttc" id="aclassIpopt_1_1IpoptApplication_html_a86039c4a135ffafbd5daf4d0f61ee83f"><div class="ttname"><a href="classIpopt_1_1IpoptApplication.html#a86039c4a135ffafbd5daf4d0f61ee83f">Ipopt::IpoptApplication::Options</a></div><div class="ttdeci">virtual SmartPtr&lt; OptionsList &gt; Options()</div><div class="ttdoc">Get the options list for setting options.</div><div class="ttdef"><b>Definition:</b> <a href="IpIpoptApplication_8hpp_source.html#l00204">IpIpoptApplication.hpp:204</a></div></div>
<div class="ttc" id="aIpReturnCodes__inc_8h_html_ab542e0b1ca364a9b7525a876ffdae7d7a98f85390ead47dbab52ac6d20aef904b"><div class="ttname"><a href="IpReturnCodes__inc_8h.html#ab542e0b1ca364a9b7525a876ffdae7d7a98f85390ead47dbab52ac6d20aef904b">Solve_Succeeded</a></div><div class="ttdeci">@ Solve_Succeeded</div><div class="ttdef"><b>Definition:</b> <a href="IpReturnCodes__inc_8h_source.html#l00015">IpReturnCodes_inc.h:15</a></div></div>
<div class="ttc" id="aIpStdCInterface_8h_html_ab974f23c40ccaad0dacd611e3f4885e9"><div class="ttname"><a href="IpStdCInterface_8h.html#ab974f23c40ccaad0dacd611e3f4885e9">Number</a></div><div class="ttdeci">IPOPT_DEPRECATED typedef ipnumber Number</div><div class="ttdoc">Type for all number.</div><div class="ttdef"><b>Definition:</b> <a href="IpStdCInterface_8h_source.html#l00031">IpStdCInterface.h:31</a></div></div>
<div class="ttc" id="aIpReturnCodes__inc_8h_html_ab542e0b1ca364a9b7525a876ffdae7d7"><div class="ttname"><a href="IpReturnCodes__inc_8h.html#ab542e0b1ca364a9b7525a876ffdae7d7">ApplicationReturnStatus</a></div><div class="ttdeci">ApplicationReturnStatus</div><div class="ttdoc">Return codes for the Optimize call for an application.</div><div class="ttdef"><b>Definition:</b> <a href="IpReturnCodes__inc_8h_source.html#l00013">IpReturnCodes_inc.h:14</a></div></div>
<div class="ttc" id="anamespaceIpopt_html_a7b95940bef97320ac5a3635114ac6114"><div class="ttname"><a href="namespaceIpopt.html#a7b95940bef97320ac5a3635114ac6114">Ipopt::IntegerMetaDataMapType</a></div><div class="ttdeci">std::map&lt; std::string, std::vector&lt; Index &gt; &gt; IntegerMetaDataMapType</div><div class="ttdef"><b>Definition:</b> <a href="IpDenseVector_8hpp_source.html#l00328">IpDenseVector.hpp:328</a></div></div>
<div class="ttc" id="aclassIpopt_1_1SmartPtr_html"><div class="ttname"><a href="classIpopt_1_1SmartPtr.html">Ipopt::SmartPtr</a></div><div class="ttdoc">Template class for Smart Pointers.</div><div class="ttdef"><b>Definition:</b> <a href="IpSmartPtr_8hpp_source.html#l00164">IpSmartPtr.hpp:165</a></div></div>
<div class="ttc" id="aIpIpoptApplication_8hpp_html_aa84adcc7d6c00fda4bac0c05db27dd0d"><div class="ttname"><a href="IpIpoptApplication_8hpp.html#aa84adcc7d6c00fda4bac0c05db27dd0d">IpoptApplicationFactory</a></div><div class="ttdeci">IPOPTLIB_EXPORT class Ipopt::IpoptApplication *IPOPT_CALLCONV IpoptApplicationFactory()</div></div>
<div class="ttc" id="aIpTypes_8h_html_a5db07e705790a30d1c9081e6910c8b27"><div class="ttname"><a href="IpTypes_8h.html#a5db07e705790a30d1c9081e6910c8b27">ipnumber</a></div><div class="ttdeci">double ipnumber</div><div class="ttdoc">Type for floating-point numbers.</div><div class="ttdef"><b>Definition:</b> <a href="IpTypes_8h_source.html#l00051">IpTypes.h:51</a></div></div>
<div class="ttc" id="aIpTypes_8h_html_ad45d5b046bfaf56789665c747d5a8cb9"><div class="ttname"><a href="IpTypes_8h.html#ad45d5b046bfaf56789665c747d5a8cb9">ipindex</a></div><div class="ttdeci">int ipindex</div><div class="ttdoc">Type of all indices of vectors, matrices etc.</div><div class="ttdef"><b>Definition:</b> <a href="IpTypes_8h_source.html#l00068">IpTypes.h:68</a></div></div>
<div class="ttc" id="anamespaceIpopt_html_a93d1b2b94faf16ee2c06be07b74c2869"><div class="ttname"><a href="namespaceIpopt.html#a93d1b2b94faf16ee2c06be07b74c2869">Ipopt::StringMetaDataMapType</a></div><div class="ttdeci">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt; StringMetaDataMapType</div><div class="ttdef"><b>Definition:</b> <a href="IpDenseVector_8hpp_source.html#l00327">IpDenseVector.hpp:327</a></div></div>
<div class="ttc" id="aclassIpopt_1_1IpoptApplication_html_ac806999950a0c1add56baac203bec6d0"><div class="ttname"><a href="classIpopt_1_1IpoptApplication.html#ac806999950a0c1add56baac203bec6d0">Ipopt::IpoptApplication::Initialize</a></div><div class="ttdeci">virtual ApplicationReturnStatus Initialize(std::istream &amp;is, bool allow_clobber=false)</div><div class="ttdoc">Initialization method.</div></div>
<div class="ttc" id="aIpStdCInterface_8h_html_ab6b7c62bfbc8dea71b3a6f724c36b377"><div class="ttname"><a href="IpStdCInterface_8h.html#ab6b7c62bfbc8dea71b3a6f724c36b377">AddIpoptStrOption</a></div><div class="ttdeci">IPOPTLIB_EXPORT bool IPOPT_CALLCONV AddIpoptStrOption(IpoptProblem ipopt_problem, char *keyword, char *val)</div><div class="ttdoc">Function for adding a string option.</div></div>
<div class="ttc" id="aIpStdCInterface_8h_html_ad1c7c5bba4e9ca11142b12c1d434764e"><div class="ttname"><a href="IpStdCInterface_8h.html#ad1c7c5bba4e9ca11142b12c1d434764e">CreateIpoptProblem</a></div><div class="ttdeci">IPOPTLIB_EXPORT IpoptProblem IPOPT_CALLCONV CreateIpoptProblem(ipindex n, ipnumber *x_L, ipnumber *x_U, ipindex m, ipnumber *g_L, ipnumber *g_U, ipindex nele_jac, ipindex nele_hess, ipindex index_style, Eval_F_CB eval_f, Eval_G_CB eval_g, Eval_Grad_F_CB eval_grad_f, Eval_Jac_G_CB eval_jac_g, Eval_H_CB eval_h)</div><div class="ttdoc">Function for creating a new Ipopt Problem object.</div></div>
<div class="ttc" id="aIpStdCInterface_8h_html_ac3aa63858b3377c5aaf789a43e5b47b5"><div class="ttname"><a href="IpStdCInterface_8h.html#ac3aa63858b3377c5aaf789a43e5b47b5">Index</a></div><div class="ttdeci">IPOPT_DEPRECATED typedef int Index</div><div class="ttdoc">Type for all indices.</div><div class="ttdef"><b>Definition:</b> <a href="IpStdCInterface_8h_source.html#l00037">IpStdCInterface.h:37</a></div></div>
<div class="ttc" id="anamespaceIpopt_html_a53a5dc5f64f568252ba7bb7385e7f834"><div class="ttname"><a href="namespaceIpopt.html#a53a5dc5f64f568252ba7bb7385e7f834">Ipopt::SolverReturn</a></div><div class="ttdeci">SolverReturn</div><div class="ttdoc">enum for the return from the optimize algorithm</div><div class="ttdef"><b>Definition:</b> <a href="IpAlgTypes_8hpp_source.html#l00019">IpAlgTypes.hpp:20</a></div></div>
<div class="ttc" id="aclassIpopt_1_1IpoptApplication_html_adc99b9f91f353063dd0a984bc3e33a82"><div class="ttname"><a href="classIpopt_1_1IpoptApplication.html#adc99b9f91f353063dd0a984bc3e33a82">Ipopt::IpoptApplication::OptimizeTNLP</a></div><div class="ttdeci">virtual ApplicationReturnStatus OptimizeTNLP(const SmartPtr&lt; TNLP &gt; &amp;tnlp)</div><div class="ttdoc">Solve a problem that inherits from TNLP.</div></div>
<div class="ttc" id="aIpIpoptApplication_8hpp_html"><div class="ttname"><a href="IpIpoptApplication_8hpp.html">IpIpoptApplication.hpp</a></div></div>
<div class="ttc" id="aIpStdCInterface_8h_html_a7af9acc5df419794044bc4c6717a89ca"><div class="ttname"><a href="IpStdCInterface_8h.html#a7af9acc5df419794044bc4c6717a89ca">AddIpoptNumOption</a></div><div class="ttdeci">IPOPTLIB_EXPORT bool IPOPT_CALLCONV AddIpoptNumOption(IpoptProblem ipopt_problem, char *keyword, ipnumber val)</div><div class="ttdoc">Function for adding a Number option.</div></div>
<div class="ttc" id="aIpStdCInterface_8h_html_a5a68928c505f008c1245088bca5b7b16"><div class="ttname"><a href="IpStdCInterface_8h.html#a5a68928c505f008c1245088bca5b7b16">IpoptSolve</a></div><div class="ttdeci">IPOPTLIB_EXPORT enum ApplicationReturnStatus IPOPT_CALLCONV IpoptSolve(IpoptProblem ipopt_problem, ipnumber *x, ipnumber *g, ipnumber *obj_val, ipnumber *mult_g, ipnumber *mult_x_L, ipnumber *mult_x_U, UserDataPtr user_data)</div><div class="ttdoc">Function calling the Ipopt optimization algorithm for a problem previously defined with CreateIpoptPr...</div></div>
<div class="ttc" id="aIpReturnCodes__inc_8h_html_a5daff61568f9909c518fb61116260387"><div class="ttname"><a href="IpReturnCodes__inc_8h.html#a5daff61568f9909c518fb61116260387">AlgorithmMode</a></div><div class="ttdeci">AlgorithmMode</div><div class="ttdoc">enum to indicate the mode in which the algorithm is</div><div class="ttdef"><b>Definition:</b> <a href="IpReturnCodes__inc_8h_source.html#l00041">IpReturnCodes_inc.h:42</a></div></div>
<div class="ttc" id="aIpStdCInterface_8h_html_ae32712b8d014ab2144fee84432e4a347"><div class="ttname"><a href="IpStdCInterface_8h.html#ae32712b8d014ab2144fee84432e4a347">IpoptProblem</a></div><div class="ttdeci">struct IpoptProblemInfo * IpoptProblem</div><div class="ttdoc">Pointer to an Ipopt Problem.</div><div class="ttdef"><b>Definition:</b> <a href="IpStdCInterface_8h_source.html#l00049">IpStdCInterface.h:49</a></div></div>
</body>
</html>
